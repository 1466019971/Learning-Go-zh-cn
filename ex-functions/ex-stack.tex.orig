<<<<<<< HEAD
\begin{Exercise}[title={栈},difficulty=1]
\label{ex:stack}
\Question \label{ex:stack q1} 创建一个固定大小保存整数的栈。
它无须超出限制的增长。定义~\func{push} 
函数——将数据放入栈，和~\func{pop} 
函数——从栈中取得内容。栈应当是后进先出（LIFO）的。

\begin{figure}[H]
\caption{一个简单的~LIFO 栈}
=======
\begin{Exercise}[title={Stack},difficulty=1]
\label{ex:stack}
\Question \label{ex:stack q1} Create a simple stack which can hold a
fixed number of ints. It does not have to grow beyond this limit.
Define \func{push} -- put something on the stack -- and \func{pop}
-- retrieve something from the stack -- functions. The stack should be
a LIFO (last in, first out) stack.

\begin{figure}[H]
\caption{A simple LIFO stack}
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
\label{fig:stack}
\begin{center}
\includegraphics[scale=0.65]{fig/stack.pdf}
\end{center}
\end{figure}

<<<<<<< HEAD
\Question \label{ex:stack q2} 更进一步。编写一个~\func{String} 方法将栈转化为字符串形式的表达。
可以这样的方式打印整个栈：
\lstinline{fmt.Printf("My stack %v\n", stack)}

\noindent{}栈可以被输出成这样的形式：
=======
\Question \label{ex:stack q2} Bonus. Write a \func{String} method which 
converts the stack to a string representation.  This way you can print the stack using:
\lstinline{fmt.Printf("My stack %v\n", stack)}

\noindent{}The stack in the figure could be represented as:
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
\texttt{[0:m] [1:l] [2:k]}

\end{Exercise}

\begin{Answer}

\Question 
%%\subsection*{Define our type} maybe nice to do this
<<<<<<< HEAD
首先定义一个新的类型来表达栈；需要一个数组（来保存键）和一个指向最后一个元素的索引。
这个小栈只能保存~10 个元素。

\begin{lstlisting}
type stack struct { |\coderemark{\emph{栈}不应该被导出}|
=======
First we define a new type that represents a stack; we need an
array (to hold the keys) and an index, which points to the last element.
Our small stack can only hold 10 elements.

\begin{lstlisting}
type stack struct { |\coderemark{\emph{stack} is not exported}|
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
    i    int 
    data [10]int  
}
\end{lstlisting}

<<<<<<< HEAD
然后需要~\func{push} 和~\func{pop} 函数来使用这个。
\emph{首先展示一下\emph{错误}{}的解法！}
在~Go 的数据传递中，是\emph{值传递}，意味着一个副本被创建并传递给函数。
\func{push} 函数的第一个版本大约是这样：

\begin{lstlisting}
func (s stack) push(k int) { |\coderemark{工作于参数的副本}|
=======
Next we need the \func{push} and \func{pop} functions to actually
use the thing. \emph{First we show the \emph{wrong}{} solution!}
In Go data passed to functions is \emph{passed-by-value} meaning a copy
is created and given to the function. The first stab for the function
\func{push} could be:

\begin{lstlisting}
func (s stack) push(k int) { |\coderemark{Works on copy of argument}|
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
	if s.i+1 > 9 {
		return
	}
	s.data[s.i] = k
	s.i++
}
\end{lstlisting}
<<<<<<< HEAD
函数对~\type{stack} 类型的变量~\var{s} 进行处理。
调用这个，只需要~\lstinline{s.push(50)}，将整数 50 放入栈中。
但是 push 函数得到的是~\var{s} 的副本，所以它\emph{不会}有\emph{真正}的结果。
用这个方法，不会有内容放入栈中，例如下面的代码：

\begin{lstlisting}
var s stack |\coderemark{让~\var{s} 是一个~\type{stack} 变量}|
=======
The function works on the \var{s} which is of the type \type{stack}. To
use this we just call \lstinline{s.push(50)}, to push the integer 50 on
the stack. But the push function gets a copy of \var{s}, so it is
\emph{not} working the \emph{real} thing. Nothing gets pushed to our
stack this way, for example the following code:

\begin{lstlisting}
var s stack |\coderemark{make \var{s} a simple \type{stack} variable}|
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
s.push(25)
fmt.Printf("stack %v\n", s);
s.push(14)
fmt.Printf("stack %v\n", s);
\end{lstlisting}
<<<<<<< HEAD
打印：
=======
prints:
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
\vskip\baselineskip
\begin{display}
stack [0:0]
stack [0:0]
\end{display}
\vskip\baselineskip

<<<<<<< HEAD
为了解决这个，需要向函数~\func{push} 提供一个指向栈的指针。
这意味着需要修改~\func{push} 
=======
To solve this we need to give the function \func{push} a pointer
to the stack. This means we need to change \func{push} from
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7

\lstinline{func (s stack) push(k int)} 
$\rightarrow$
\lstinline{func (s *stack) push(k int)}

<<<<<<< HEAD
应当使用~\func{new()}（参阅第~\ref{chap:beyond} 章``\titleref{sec:allocation with new}''小节）
创建\emph{指针}指向的~\type{stack} 的空间，因此例子中的第~1 行需要是
\lstinline{s := new(stack)}

\noindent{}而两个函数变为：
=======
We should now use \func{new()} (see ``\titleref{sec:allocation with new}''
in chapter \ref{chap:beyond}) to create a \emph{pointer} to a newly
allocated \type{stack}, so line 1 from the example above needs to be
\lstinline{s := new(stack)}

\noindent{}And our two functions become:
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
\begin{lstlisting}
func (s *stack) push(k int) {
	s.data[s.i] = k
	s.i++
}

func (s *stack) pop() int {
	s.i--
	return s.data[s.i]
}
\end{lstlisting}
<<<<<<< HEAD
像下面这样使用
=======
Which we then use as follows
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
\begin{lstlisting}
func main() {
	var s stack
	s.push(25)
	s.push(14)
	fmt.Printf("stack %v\n", s)
}
\end{lstlisting}

<<<<<<< HEAD
\Question 这里有一个额外的问题，对于这个练习中编写打印栈的代码的时候非常有价值。
根据~Go 文档~\lstinline{fmt.Printf("\%v")} 可以打印实现了~\func{Stringer} 接口的任何值（\%v）。
为了使其工作，需要为类型定义一个~\func{String()} 函数：
=======
\Question While this was a bonus question, having the ability to print
the stack was very valuable when writing the code for this exercise.
According to the Go documentation \lstinline{fmt.Printf("%v")} can
print any value (\%v) that satisfies the \func{Stringer} interface.
For this to work we only need to define a \func{String()} function for
our type:
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
\begin{lstlisting}[caption=stack.String()]
func (s stack) String() string {
	var str string
	for i := 0; i <= s.i; i++ {
		str = str + "[" +
			strconv.Itoa(i) + ":" + strconv.Itoa(s.data[i]) + "]"
	}
	return str
}
\end{lstlisting}
\end{Answer}
