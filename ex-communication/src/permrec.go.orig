package main

<<<<<<< HEAD
// 为了增加而需要重写
import ( "fmt"; "strconv"; "flag" )
=======
import ( "fmt"; "strconv"; "flag")
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7

const (
	_ = 1000 * iota
	ADD
	SUB
	MUL
	DIV
	MAXPOS = 11
)

<<<<<<< HEAD
var mop = map[int]string{ADD: "+", SUB: "-", MUL: "*", DIV: "/",}

=======
var mop = map[int]string{ADD: "+", SUB: "-", MUL: "*", DIV: "/"}
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
var (
	ok    bool
	value int
)

type Stack struct {
	i    int
	data [MAXPOS]int
}

func (s *Stack) Reset()     { s.i = 0 }
<<<<<<< HEAD

func (s *Stack) Len() int   { return s.i }

func (s *Stack) Push(k int) { s.data[s.i] = k; s.i++ }

=======
func (s *Stack) Len() int   { return s.i }
func (s *Stack) Push(k int) { s.data[s.i] = k; s.i++ }
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
func (s *Stack) Pop() int   { s.i--; return s.data[s.i] }

var found int
var stack = new(Stack)

func main() {
	flag.Parse()
	list := []int{1, 6, 7, 8, 8, 75, ADD, SUB, MUL, DIV}
<<<<<<< HEAD
        magic, ok := strconv.Atoi(flag.Arg(0))  // Arg0 是 i
        if ok != nil { return }
=======
	magic, ok := strconv.Atoi(flag.Arg(0))	// Arg0 is i
	if ok != nil { return }
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
	f := make([]int, MAXPOS)
	solve(f, list, 0, magic)
}

func solve(form, numberop []int, index, magic int) {
	var tmp int
	for i, v := range numberop {
<<<<<<< HEAD
                if v == 0 { goto NEXT }
		if v < ADD { // 是一个数字，保存起来
=======
		if v == 0 { goto NEXT }
		if v < ADD { // it's a number, save it
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
			tmp = numberop[i]
			numberop[i] = 0
		}
		form[index] = v
		value, ok = rpncalc(form[0 : index+1])

		if ok && value == magic {
			if v < ADD {
<<<<<<< HEAD
				numberop[i] = tmp // 重置并继续
=======
				numberop[i] = tmp // reset and go on
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
			}
			found++
			fmt.Printf("%s = %d  #%d\n", rpnstr(form[0:index+1]), value, found)
		}

		if index == MAXPOS-1 {
			if v < ADD {
<<<<<<< HEAD
				numberop[i] = tmp // 重置并继续
=======
				numberop[i] = tmp // reset and go on
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
			}
			goto NEXT
		}
		solve(form, numberop, index+1, magic)
		if v < ADD {
<<<<<<< HEAD
			numberop[i] = tmp // 重置并继续
=======
			numberop[i] = tmp // reset and go on
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
		}
	NEXT:
	}
}

<<<<<<< HEAD
func rpnstr(r []int) (ret string) { // 将 rpn 转换到固定的标记
        s := make([]string, 0) // 分配内存
	for k, t := range r {
		switch t {
		case ADD, SUB, MUL, DIV:
                        a, s := s[len(s)-1], s[:len(s)-1]
                        b, s := s[len(s)-1], s[:len(s)-1]
                        if k == len(r)-1 {
			        s = append(s, b+mop[t]+a)
                        } else {
                                s = append(s, "("+b+mop[t]+a+")")
			}
		default:
                        s = append(s, strconv.Itoa(t))
=======
func rpnstr(r []int) (ret string) {	// Convert rpn to infix notation
	s := make([]string, 0) // Still memory intensive
	for k, t := range r {
		switch t {
		case ADD, SUB, MUL, DIV:
			a, s := s[len(s)-1], s[:len(s)-1]
			b, s := s[len(s)-1], s[:len(s)-1]
			if k == len(r)-1 {
				s = append(s, b+mop[t]+a)
			} else {
				s = append(s, "("+b+mop[t]+a+")")
			}
		default:
			s = append(s, strconv.Itoa(t))
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
		}
	}
	for _, v := range s { ret += v }
	return
}

func rpncalc(r []int) (int, bool) {
	stack.Reset()
	for _, t := range r {
		switch t {
		case ADD, SUB, MUL, DIV:
			if stack.Len() < 2 { return 0, false }
			a := stack.Pop()
			b := stack.Pop()
<<<<<<< HEAD
			if t == ADD { stack.Push(b + a)	}
			if t == SUB {
				// 不接受负数
=======
			if t == ADD { stack.Push(b + a) }
			if t == SUB {
				// disallow negative subresults
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
				if b-a < 0 {
					return 0, false
				}
				stack.Push(b - a)
			}
<<<<<<< HEAD
			if t == MUL { stack.Push(b * a)	}
=======
			if t == MUL { stack.Push(b * a) }
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
			if t == DIV {
				if a == 0 {
					return 0, false
				}
<<<<<<< HEAD
				// 不接受余数
=======
				// disallow fractions
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
				if b%a != 0 {
					return 0, false
				}
				stack.Push(b / a)
			}
		default:
			stack.Push(t)
		}
	}
<<<<<<< HEAD
	if stack.Len() == 1 { // 只有一个！
=======
	if stack.Len() == 1 { // there is only one!
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
		return stack.Pop(), true
	}
	return 0, false
}
