<<<<<<< HEAD
\begin{Exercise}[title={方法调用},difficulty=2]
\label{ex:methodcalls}
\Question \label{ex:methodcalls q1} 假设有下面的程序。
要注意的是包 \package{container/vector} 曾经是 Go 的一部分，但是当内建的
\func{append} 出现后，就被移除了。
然而，对于当前的问题这不重要。这个包实现了有 push 和 pop 方法的栈结构。

=======
\begin{Exercise}[title={Method calls},difficulty=2]
\label{ex:methodcalls}
\Question \label{ex:methodcalls q1} Suppose we have the following
program. Note the package \package{container/vector} was once part
of Go, but has been removed when the \func{append} built-in was introduced.
However, for this question this isn't important. The package implemented
a stack-like structure, with push and pop methods.
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
\begin{lstlisting}
package main

import "container/vector"

func main() {
	k1 := vector.IntVector{}
	k2 := &vector.IntVector{}
	k3 := new(vector.IntVector)
	k1.Push(2)
	k2.Push(3)
	k3.Push(4)
}
\end{lstlisting}
<<<<<<< HEAD
\var{k1}，\var{k2} 和 \var{k3} 的类型是什么？

\Question 当前，这个程序可以编译并且运行良好。在不同类型的变量上 \func{Push}
都可以工作。\func{Push} 的文档这样描述：
\begin{quote}
func (p *IntVector) Push(x int)
Push 增加 x 到向量的末尾。
\end{quote}
那么接受者应当是 \type{*IntVector} 类型，为什么上面的代码（Push 语句）可以正确工作？
=======
What are the types of \var{k1}, \var{k2} and \var{k3}?

\Question Now, this program compiles and runs OK. All the \func{Push}
operations work even though the variables are of a different type. The
documentation for \func{Push} says:
\begin{quote}
func (p *IntVector) Push(x int)
Push appends x to the end of the vector.
\end{quote}
So the receiver has to be of type \type{*IntVector}, why does the code
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
above (the Push statements) work correct then?

\end{Exercise}

\begin{Answer}
<<<<<<< HEAD
\Question \var{k1} 的类型是 \type{vector.IntVector}。为什么？
这里使用了符号 \verb|{}|，因此获得了类型的值。
变量 \var{k2} 是 \type{*vector.IntVector}，因为获得了复合语句的地址（\verb|&|）。
而最后的 \var{k3} 同样是 \type{*vector.IntVector} 类型，因为 \func{new}
返回该类型的指针。

\Question 在 \cite{go_spec} 的``调用''章节，有这样的描述：
\begin{quote}
当 \var{x} 的方法集合包含 \func{m}，
并且参数列表可以赋值给 \func{m} 的参数，方法调用 \func{x.m()} 是合法的。
如果 \var{x} 可以被地址化，而 \var{\&x} 的方法集合包含 \func{m}，
\func{x.m()} 可以作为 \func{(\&x).m()} 的省略写法。
\end{quote}
换句话说，由于 \var{k1} 可以被地址化，而 \type{*vector.IntVector}
\emph{具有} \func{Push} 方法，调用 \lstinline{k1.Push(2)} 被 Go 转换为 
\lstinline{(&k1).Push(2)} 来使型系统愉悦（也使你愉悦——现在你已经了解到这一点）。
\footnote{参阅本章的第 ``\titleref{sec:methods}'' 节。}
=======
\Question The type of \var{k1} is \type{vector.IntVector}. Why? We use 
a composite literal (the \verb|{}|), so we get a value of that type
back. The variable \var{k2} is of \type{*vector.IntVector}, because we
take the address (\verb|&|) of the composite literal. And finally
\var{k3} has also the type \type{*vector.IntVector}, because \func{new}
returns a pointer to the type.

\Question The answer is given in \cite{go_spec} in the section ``Calls'',
where among other things it says:
\begin{quote}
A method call \func{x.m()} is valid if the method set of (the type of)
\var{x}
contains \func{m} and the argument list can be assigned to the parameter list
of \func{m}. If \var{x} is addressable and \var{\&x}'s method set
contains \func{m}, \func{x.m()} is shorthand for \func{(\&x).m()}.
\end{quote}
In other words because \var{k1} is addressable and
\type{*vector.IntVector} \emph{does} have the \func{Push} method, the
call \lstinline{k1.Push(2)} is translated by Go into 
\lstinline{(&k1).Push(2)} which makes the type system happy again (and
you too --- now you know this).\footnote{Also see section
``\titleref{sec:methods}'' in this chapter.}
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7

\end{Answer}
