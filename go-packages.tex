\epi{\lstinline{^}}{\textit{Answer to whether there is a bitwise negation
operator.}\\\textsc{Ken Thompson}}
\noindent{}Packages are a collection of functions and data, they are sort alike the
Perl packages\cite{perl-packages}. You declare a package with the
\lstinline{package} keyword. Note that the filename should
match the package name. Lets define our package \package{even} in the file
\prog{even.go}

\lstinputlisting[label=src:even,caption=A small package]{src/even.go}
Names that start with a capital letterare exported and may be used
outside your package, more on that later. We can now use
the package as follows in our own program \prog{myeven.go}:

\lstinputlisting[label=src:myeven,caption=Use of the \package{even} package]{src/myeven.go}
Now we just need to compile and link, first the package, then \prog{myeven.go} and
then link it:
\begin{display}
\pr 6g even.go			\qquad\qquad\rem{# package}
\pr 6g myeven.go		\qquad\qquad\rem{# our program}
\pr 6l -o myeven myeven.8
\end{display}
And now we can test it:
\begin{display}
\pr ./myeven
Is 5 even? false
\end{display}

In Go, a function from a package is exported (visible
outside the package, i.e. public) when the first letter of the function name is a capital, hence
the function name \func{\emph{E}ven}. If we change our \prog{myeven.go} on line
7 to using to unexported funtion \func{even.uneven}:

\noindent\lstinline{fmt.Printf("Is %d even? %v\n", i, even.uneven(i))}

We get an error when compiling, because we are trying to use a
\emph{private} function:
\begin{display}
myeven.go:7: cannot refer to unexported name even.uneven
myeven.go:7: undefined: even.uneven
\end{display}
To summarise:
\begin{itemize}
\item Public functions have a name \emph{starting} with a Capital
Letter;
\item Private function have a name starting with a lowercase letter.
\end{itemize}

\section{Building}
The create a package other people can use (by just using
\lstinline{import "even"}) we first need to create a directory
where we put our package files in. 
\begin{display}
\pr mkdir even
\pr cp even.go even
\end{display}
Next we 
can use the following Makefile, which 
is adapted for our \package{even} package.
\begin{lstlisting}[language=make,caption=A Makefile for packages]
# Copyright 2009 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

include $(GOROOT)/src/Make.$(GOARCH)

TARG=even		# the name of our package
GOFILES=\
	even.go\	# the file(s) in the even package

include $(GOROOT)/src/Make.pkg

\end{lstlisting}
If we now issue \prog{make} we create this directory structure:
\begin{display}
\pr ls -l even

\end{display}
With \prog{make install} the package is installed in the \emph{official}
package directory:
\begin{display}
\pr ls -l \$GOROOT/pkg/dkdlskdls bla
\end{display}

\section{Names}
Names are as important in Go as in any other language. In some cases
they even have semantic effect: for instance, the visibility of a name
outside a package is determined by whether its first character is upper
case. It's therefore worth spending a little time talking about naming
conventions in Go programs.

The convention we adopted was to leave well-known legacy
not-quite-words alone rather than try to figure out where
the capital letters go.  \lstinline{Atoi}, \lstinline{Getwd},
\lstinline{Chmod}.
Camelcasing works best when you have whole words
to work with: \lstinline{ReadFile, NewWriter, MakeSlice}

\subsection{Package names}
When a package is imported, the package name becomes an accessor for the
contents. After
\begin{lstlisting}
import "bytes"
\end{lstlisting}
the importing package can talk about \func{bytes.Buffer}. It's helpful if
everyone using the package can use the same name to refer to its
contents, which implies that the package name should be good: short,
concise, evocative. By convention, packages are given lower case,
single-word names; there should be no need for underscores or mixedCaps.
Err on the side of brevity, since everyone using your package will be
typing that name. And don't worry about collisions a priori. The package
name is only the default name for imports; it need not be unique across
all source code, and in the rare case of a collision the importing
package can choose a different name to use locally. In any case,
confusion is rare because the file name in the import determines just
which package is being used.

Another convention is that the package name is the base name of its
source directory; the package in \package{src/pkg/container/vector} is imported as
"container/vector" but has name vector, not container\_vector and not
containerVector.

The importer of a package will use the name to refer to its contents, so 
exported names in the package can use that fact to avoid
stutter. For instance, the buffered reader type in the \package{bufio} package is
called \func{Reader}, not \func{BufReader}, because users see it as
\func{bufio.Reader},
which is a clear, concise name. Moreover, because imported entities are
always addressed with their package name, \func{bufio.Reader} does not conflict
with \func{io.Reader}. Similarly, the function to make new instances of
\func{ring.Ring}---which is the definition of a constructor in Go---would normally
be called NewRing, but since Ring is the only type exported by the
package, and since the package is called \package{ring}, it's called
just \func{New}.
Clients of the package see that as \func{ring.New}. Use the package structure
to help you choose good names.

Another short example is \func{once.Do}; \func{once.Do(setup)} reads well and would
not be improved by writing \lstinline{once.DoOrWaitUntilDone(setup)}. Long names
don't automatically make things more readable. If the name represents
something intricate or subtle, it's usually better to write a helpful
doc comment than to attempt to put all the information into the name.

\paragraph{MixedCaps}
Finally, the convention in Go is to use MixedCaps or mixedCaps rather
than underscores to write multiword names.

When Go was released as open source software in December 2009 it came
with a boatload of packages. In this chapter we show how to use some
of these.

\section{Initialization}
Every source file in a package can define an \func{init()} function. This function is
called after the variables in the package have gotten their value. The
\func{init()} function can be used to setup state before the execution
begins.

Var section TODO(miekg)

\section{Documenting packages}
From \cite{effective_go}
Every package should have a \emph{package comment}, a block comment preceding the
 \key{package} clause. For multi-file packages, the package comment only needs to be
present in one file, and any one will do. The package comment should introduce
the package and provide information relevant to the package as a whole. It will
appear first on the \prog{godoc} page and should set up the detailed documentation
that follows.

An example is:
\begin{display}
/*
    The regexp package implements a simple library for
    regular expressions.

    The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '\$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
\end{display}





\section{Testing packages}
In Go it is customary to write (unit) tests for your package. Writing
tests involves the \package{testing}.
\begin{lbar}
Read the package doc!
\end{lbar}

The testing itself is carried out with \prog{gotest}.
The \prog{gotest} program run all the test functions, each
test function has the same signature:
\begin{lstlisting}
func TestXxx(t *testing.T) |\coderemark{Test<Capital>restOftheName}|
\end{lstlisting}

When writing test you will need to tell \prog{gotest} that a test has failed or was successful. A
successful test function just returns. When test fails you can signal this with the following
functions\cite{go_doc}. These are the most important ones:

\begin{lstlisting}[numbers=none]
func (t *T) Fail()
\end{lstlisting}
Fail marks the Test function as having failed but continues execution.

\begin{lstlisting}[numbers=none]
func (t *T) FailNow()
\end{lstlisting}
FailNow marks the Test function as having failed and stops its execution.
Execution will continue at the next Test.

\begin{lstlisting}[numbers=none]
func (t *T) Errorf(format string, args ...interface{})
\end{lstlisting}
Errorf is equivalent to Logf() followed by Fail().

\begin{lstlisting}[numbers=none]
func (t *T) Logf(format string, args ...interface{})
\end{lstlisting}
Log formats its arguments according to the format, analogous to Printf(),
and records the text in the error log.

\begin{lstlisting}[numbers=none]
func (t *T) Fatal(args ...interface{})
\end{lstlisting}
Fatal is equivalent to Log() followed by FailNow().


\begin{lstlisting}[numbers=none]
func (t *T) Failed() bool
\end{lstlisting}
Failed returns whether the Test function has failed.




\section{Useful packages}



\subsection{fmt}

\subsection{flag}
argument parsing

\subsection{unsafe}

\subsection{reflect}

\section{Building}
A complete building section, Makefile, local packages.

\section{Exercises}
\input{ex-packages/ex-scope.tex}

\cleardoublepage
\section{Answers}
\shipoutAnswer
