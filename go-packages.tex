\epi{\lstinline{^}}{Ken Thompson's answer to whether there is a bitwise negation
operator.}\noindent

When Go was released as open source software in December 2009 it came
with a boatload of packages. In this chapter we show how to use some
of these.


\section{Documenting packages}
From \cite{effective_go}
Every package should have a \emph{package comment}, a block comment preceding the
 \key{package} clause. For multi-file packages, the package comment only needs to be
present in one file, and any one will do. The package comment should introduce
the package and provide information relevant to the package as a whole. It will
appear first on the \prog{godoc} page and should set up the detailed documentation
that follows.

An example is:
\begin{display}
/*
    The regexp package implements a simple library for
    regular expressions.

    The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '\$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
\end{display}





\section{Testing packages}
In Go it is customary to write (unit) tests for your package. Writing
tests involves the \package{testing}.
\begin{lbar}
Read the package doc!
\end{lbar}

The testing itself is carried out with \prog{gotest}.
The \prog{gotest} program run all the test functions, each
test function has the same signature:
\begin{lstlisting}
func TestXxx(t *testing.T) |\coderemark{Test<Capital>restOftheName}|
\end{lstlisting}

When writing test you will need to tell \prog{gotest} that a test has failed or was successful. A
successful test function just \func{return}s. When test fails you can signal this with the following
functions\cite{go_doc}. These are the most important ones:

\begin{lstlisting}[numbers=none]
func (t *T) Fail()
\end{lstlisting}
Fail marks the Test function as having failed but continues execution.

\begin{lstlisting}[numbers=none]
func (t *T) FailNow()
\end{lstlisting}
FailNow marks the Test function as having failed and stops its execution.
Execution will continue at the next Test.

\begin{lstlisting}[numbers=none]
func (t *T) Errorf(format string, args ...interface\{\})
\end{lstlisting}
Errorf is equivalent to Logf() followed by Fail().

\begin{lstlisting}[numbers=none]
func (t *T) Logf(format string, args ...interface\{\})
\end{lstlisting}
Log formats its arguments according to the format, analogous to Printf(),
and records the text in the error log.

\begin{lstlisting}[numbers=none]
func (t *T) Fatal(args ...interface\{\})
\end{lstlisting}
Fatal is equivalent to Log() followed by FailNow().




\begin{lstlisting}[numbers=none]
func (t *T) Failed() bool
\end{lstlisting}
Failed returns whether the Test function has failed.




\section{Useful packages}



\subsection{fmt}

\subsection{flag}
argument parsing

\subsection{unsafe}


\section{Exercises}

\cleardoublepage
\section{Answers}
\shipoutAnswer
