package main
<<<<<<< HEAD

=======
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
import ( "os"; "bufio")

func main() {
	buf := make([]byte, 1024)
<<<<<<< HEAD
        f, _ := os.Open("/etc/passwd") |\longremark{打开文件；}|
	defer f.Close()
        r := bufio.NewReader(f) |\longremark{转换 \var{f} 为有缓冲的 \func{Reader}。%
\func{NewReader} 需要一个 \type{io.Reader}，因此或许你认为这会出错。%
但其实不会。\emph{任何}有 \func{Read()} 函数就实现了这个接口。%
同时，从列表\ref{src:read}可以看到，\type{*os.File} 已经这样做了；}|	w := bufio.NewWriter(os.Stdout)
	defer w.Flush()
	for {
                n, _ := r.Read(buf)     |\longremark{从 Reader 读取，而向 Writer 写入，然后%
向屏幕输出文件。}|
=======
	f, _ := os.Open("/etc/passwd") |\longremark{Open the file;}|
	defer f.Close()
	r := bufio.NewReader(f) |\longremark{Turn \var{f} into a buffered \func{Reader}. %
\func{NewReader} expects an \type{io.Reader}, so you %
might think this will fail. But it does not. %
\emph{Anything} that has such a \func{Read()} function implements this %
interface. And from listing \ref{src:read} we can see %
that \type{*os.File} indeed does so;}|
	w := bufio.NewWriter(os.Stdout)
	defer w.Flush()
	for {
		n, _ := r.Read(buf)     |\longremark{Read from the Reader and write to the Writer, and thus %
print the file to the screen.}|
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
		if n == 0 { break }
		w.Write(buf[0:n])
	}
}
<<<<<<< HEAD
=======

>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
