\epi{“好的沟通就像是一杯刺激的浓咖啡，然后就难以入睡。”}{\textsc{ANNE MORROW LINDBERGH}}
\noindent{}在这章中将介绍 Go 中与外部通讯的通讯模块。

\section{文件}
在 Go 中，从文件读取（或写入）是非常容易的。程序只需要使用
\package{os} 包就可以从文件 \file{/etc/passwd} 中读取数据。
\lstinputlisting[caption=从文件读取（无缓冲）,label=src:read]{src/file.go}
\showremarks

如果想要使用\first{缓冲}{buffered} IO，则有
\package{bufio}\index{package!bufio} 包：
\lstinputlisting[caption=从文件读取（缓冲）,label=src:bufread]{src/buffile.go}
\showremarks

更加通用的方法（但是也略微复杂一点）是 \func{ReadLine}，参阅 \package{bufio} 包的文档。

\subsection{一行行}
前面的程序将整个文件读出，但是通常情况下会希望一行一行的读取。下面的片段展示了如何实现：

\begin{lstlisting}
f, _ := os.Open("/etc/passwd", os.O_RDONLY, 0666)
r := bufio.NewReader(f)
for {
    s, ok := r.ReadString('\n'); true { |\coderemark{从输入中读取一行}|
    // ... |\coderemark{\var{s} 保存了字符串，通过 \package{string} 包就可以解析它}|

}
\end{lstlisting}

\section{命令行参数}
\label{sec:option parsing}
来自命令行的参数在程序中通过字符串 slice \var{os.Args} 获取，导入包 \package{os} 即可。
\package{flag} 包有着精巧的接口，同样提供了解析标识的方法。这个例子是一个简单的 DNS 查询工具：
\begin{lstlisting}
var dnssec *bool = flag.Bool("dnssec", false, "Request DNSSEC records") |\longremark{定义 \texttt{bool} 标识，%%
\texttt{-dnssec}。变量必须是指针，否则 package 无法设置其值；}|
var port *string = flag.String("port", "53", "Set the query port")      |\longremark{类似的，\texttt{port} 选项；}|
flag.Usage = func() {   |\longremark{简单的重定义 \func{Usage} 函数，有点罗嗦；}|
    fmt.Fprintf(os.Stderr, "Usage: %s [@server] [qtype] [qclass] [name ...]\n", os.Args[0])
    flag.PrintDefaults() |\longremark{指定的每个标识，\func{PrintDefaults} 将输出帮助信息；}|
}
flag.Parse()   |\longremark{解析标识，并填充变量。}|
\end{lstlisting}
\showremarks

\section{执行命令}
\package{exec}\index{package!exec} 包有函数可以执行外部命令，这也是在 Go 中主要的执行命令的方法。
\func{Run} 函数执行命令：
\begin{lstlisting}
func Run(argv0 string, argv, envv []string, dir string, stdin, stdout, stderr int) (p *Cmd, err os.Error)
\end{lstlisting}
\begin{quote}
Run 开启一个参数为 \var{argv} 并且环境变量为 \var{envv} 的二进制程序。
返回一个新的描述命令的 \type{Cmd} 类型指针，或是错误。
\end{quote}
执行 \verb|ls -l|：
\begin{lstlisting}
import "exec"

cmd, err := exec.Run("/bin/ls", []string{"ls", "-l"}, nil, "", exec.DevNull, exec.DevNull, exec.DevNull)
\end{lstlisting}
在 \package{os}\index{package!os} 包中，可以找到 \func{StartProcess} 函数。这是另外一个方法（但是更底层一些）执行命令。
\footnote{在 go-nuts 上，有一些关于 \func{Fork} 和 \func{Exec} 区别的讨论。} 
\func{StartProcess} 的原型是：
\begin{lstlisting}
func StartProcess(name string, argv []string, envv []string, dir string, fd []*File) (pid int, err Error)
\end{lstlisting}
有下面的文档：
\begin{quote}
\func{StartProcess} 启动一个程序新的进程，通过 \var{name}、\var{argv} 和 \var{envv} 指定程序、参数和环境变量。
\var{fd} 数组指定了新进程的文件描述符：\var{fd[0]} 是 Unix 文件描述符 0（标准输入），
\var{fd[1]} 是描述符 1，等等。输入 \type{nil} 将使得子进程在那个索引上没有打开的文件描述符。
如果 \var{dir} 不为空，子进程在执行前会 chdir 到这个目录。
\end{quote}
假设希望再次执行 \verb|ls -l|：
\begin{lstlisting}
import "os"

pid, err := os.StartProcess("/bin/ls", []string{"ls", "-l"}, nil, "", []*os.File{ os.Stdin, os.Stdout, os.Stderr})
defer os.Wait(pid, os.WNOHANG) |\coderemark{否则会创建僵尸进程}|
\end{lstlisting}
注意 \lstinline{os.Wait} （以及其他）返回 \func{退出码}，这样：
\begin{lstlisting}
w := os.Wait(pid, os.WNOHANG)
e := w.WaitStatus.ExitStatus()  |\coderemark{ExitStatus() 返回整数}|
\end{lstlisting}

\section{网络}
所有网络相关的类型和函数可以在 \package{net} 包中找到。这其中最重要的函数是 \func{Dial}\index{networking!Dial}。
当 \func{Dial} 到远程系统，这个函数返回 \var{Conn} 接口类型，可以用于发送或接收信息。
函数 \func{Dial} 简洁的抽象了网络层和传输层。因此 IPv4 或者 IPv6，TCP 或者 UDP 可以共用一个接口。

通过 TCP 连接到远程系统（端口 80），然后是 UDP，最后是 TCP 通过 IPv6，大致是这样：
\footnote{在这个例子中，可以认为 192.0.32.10 和 2620:0:2d0:200::10 是 \url{www.example.org}。}
\begin{lstlisting}
conn, err := Dial("tcp", "", "192.0.32.10:80")
conn, err := Dial("udp", "", "192.0.32.10:80")
conn, err := Dial("tcp", "", "[2620:0:2d0:200::10]:80") |\coderemark{方括号是强制的}|
\end{lstlisting}

而通过 \var{conn} 可以进行读写\todo{dkls}。

\todo{编写一个 echo server}

\section{Netchan：网络和 channel}
%%http://blog.golang.org/2010/09/go-concurrency-patterns-timing-out-and.html


\section{练习}
\input{ex-communication/ex-processes.tex}

\input{ex-communication/ex-wordcount.tex}

\input{ex-communication/ex-uniq.tex}

\input{ex-communication/ex-quine.tex}

\input{ex-communication/ex-numbercruncher.tex}

\cleardoublepage
\section{答案}
\shipoutAnswer
