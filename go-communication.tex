\epi{“好的沟通就像是一杯刺激的浓咖啡，然后就难以入睡。”}{\textsc{ANNE MORROW LINDBERGH}}
\noindent{}在这章中将介绍 Go 中与外部通讯的通讯模块。

\section{文件}
在 Go 中，从文件读取（或写入）是非常容易的。程序只需要使用
\package{os} 包就可以从文件 \file{/etc/passwd} 中读取数据。
\lstinputlisting[caption=从文件读取（无缓冲）,label=src:read]{src/file.go}
\showremarks
如果想要使用\first{缓冲}{buffered} IO，则有
\package{bufio}\index{package!bufio} 包：
\lstinputlisting[caption=从文件读取（缓冲）,label=src:bufread]{src/buffile.go}
\showremarks

更加通用的方法（但是也略微复杂一点）是 \func{ReadLine}，参阅 \package{bufio} 包的文档。

\subsection{一行行}
前面的程序将整个文件读出，但是通常情况下会希望一行一行的读取。下面的片段展示了如何实现：

\begin{lstlisting}
f, _ := os.Open("/etc/passwd")
defer f.Close()
r := bufio.NewReader(f)
s, ok := r.ReadString('\n') {|\coderemark{从输入中读取一行}|
// ... |\coderemark{\var{s} 保存了字符串，通过 \package{string} 包就可以解析它}|
\end{lstlisting}

\section{命令行参数}
\label{sec:option parsing}
来自命令行的参数在程序中通过字符串 slice \var{os.Args} 获取，导入包 \package{os} 即可。
\package{flag} 包有着精巧的接口，同样提供了解析标识的方法。这个例子是一个 DNS 查询工具：
\begin{lstlisting}
dnssec := flag.Bool("dnssec", false, "Request DNSSEC records") |\longremark{定义 \texttt{bool} 标识，%%
\texttt{-dnssec}。变量必须是指针，否则 package 无法设置其值；}|
port := flag.String("port", "53", "Set the query port")      |\longremark{类似的，\texttt{port} 选项；}|
flag.Usage = func() {   |\longremark{简单的重定义 \func{Usage} 函数，有点罗嗦；}|
    fmt.Fprintf(os.Stderr, "Usage: %s [OPTIONS] [name ...]\n", os.Args[0])
    flag.PrintDefaults() |\longremark{指定的每个标识，\func{PrintDefaults} 将输出帮助信息；}|
}
flag.Parse()   |\longremark{解析标识，并填充变量。}|
\end{lstlisting}
\showremarks

\section{执行命令}
\package{exec}\index{package!exec} 包有函数可以执行外部命令，这也是在 Go 中主要的执行命令的方法。
通过定义一个有着数个方法的 \var{*exec.Cmd} 结构来使用。

执行 \verb|ls -l|：
\begin{lstlisting}
import "exec"

cmd := exec.Command("/bin/ls", "-l")
err := cmd.Run()
\end{lstlisting}
从命令行的标准输出中获得信息同样简单：
\begin{lstlisting}
import "exec"

cmd := exec.Command("/bin/ls", "-l")
buf, err := cmd.Output()    |\coderemark{\var{buf} 是一个 \type{[]byte}}|
\end{lstlisting}

\section{网络}
所有网络相关的类型和函数可以在 \package{net} 包中找到。这其中最重要的函数是 \func{Dial}\index{networking!Dial}。
当 \func{Dial} 到远程系统，这个函数返回 \var{Conn} 接口类型，可以用于发送或接收信息。
函数 \func{Dial} 简洁的抽象了网络层和传输层。因此 IPv4 或者 IPv6，TCP 或者 UDP 可以共用一个接口。

通过 TCP 连接到远程系统（端口 80），然后是 UDP，最后是 TCP 通过 IPv6，大致是这样：
\footnote{在这个例子中，可以认为 192.0.32.10 和 2620:0:2d0:200::10 是 \url{www.example.org}。}
\begin{lstlisting}
conn, _ := Dial("tcp", "192.0.32.10:80")
conn, _ := Dial("udp", "192.0.32.10:80")
conn, _ := Dial("tcp", "[2620:0:2d0:200::10]:80") |\coderemark{方括号是强制的}|
\end{lstlisting}

如果没有错误，就可以使用 \var{conn} 从套接字中读写。
在包 \package{net} 中的原始定义是：
\begin{quote}
// \func{Read} reads data from the connection.\\
// \func{Read} can be made to time out and return a \var{net.Error} with \lstinline{Timeout() == true}\\
// after a fixed time limit; see \func{SetTimeout} and \func{SetReadTimeout}.\\
\lstinline{Read(b []byte) (n int, err os.Error)}
\end{quote}

\begin{quote}
// \func{Write} writes data to the connection.\\
// \func{Write} can be made to time out and return a \var{net.Error} with \lstinline{Timeout() == true}\\
// after a fixed time limit; see \func{SetTimeout} and \func{SetWriteTimeout}.\\
\lstinline{Write(b []byte) (n int, err os.Error)}
\end{quote}

% \todo{编写一个 echo server}

\section{Netchan：网络和 channel}
%%http://blog.golang.org/2010/09/go-concurrency-patterns-timing-out-and.html

\section{练习}
\input{ex-communication/ex-processes.tex}

\input{ex-communication/ex-wordcount.tex}

\input{ex-communication/ex-uniq.tex}

\input{ex-communication/ex-quine.tex}

\input{ex-communication/ex-numbercruncher.tex}

\cleardoublepage
\section{答案}
\shipoutAnswer
