%%\epi{I'm always delighted by the light touch and stillness of
%%early programming languages.  Not much text; a lot gets
%%done. Old programs read like quiet conversations
%%between a well-spoken research worker and a well-
%%studied mechanical colleague, not as a debate with a
%%compiler.  Who'd have guessed sophistication bought
%%such noise?}{Dick Gabriel}
\epi{"I am interested in this and hope to do something."}
{Ken Thompson on adding complex numbers to Go}

\noindent{}This is an introduction to the Go language from Google. Its aim
is to provide a guide to this new and innovative language. As with
learning new things, the best way to do this is to discover it for
yourself. Thus each chapter includes a number of exercises (and answers)
to acquaint you with the language.
Its intended audience is people who are familiar with programming
and know different languages, be it C\cite{c}, C$^{++}$\cite{c++}, 
Java \cite{java}, Erlang\cite{erlang}, Scala\cite{scala} or
Haskell\cite{haskell}. This is \emph{not} a book which teaches you how to 
program, this is a book that teaches you how to use Go.

\begin{lbar}
\noindent The Go language is a young language and
features are still added or even \emph{removed}. Whenever
possible there will be a warning in the margin saying that
something is a new feature. This will be accompanied with
the Go version where this was included first, as in
\texttt{\tiny{}Go release.2010-02-04}.
\end{lbar}

Each chapter concludes with a number of exercises. An exercise
is numbered as \textbf{Q$n$}, where $n$ is a number. After the
exercise number another number in parentheses displays the difficulty
of this particular assignment. This difficulty ranges from 0 to 9, where
0 is easy and 9 is extremely difficult (or at least it should be).
Then a short name is given, for easier reference.
For example
\begin{verse}
\textbf{Q1}. (4) A map function \ldots
\end{verse}
    
\noindent gives a question numbered \textbf{Q1} of a level 4 difficulty, concerning a
\func{map()}-function. The answers are included after the exercises on a
new page.
The numbering and setup of the answers is identical to the
exercises, except that an answer starts with \textbf{A$n$}, where the
number $n$ corresponds with the number of the exercise.

All the included source code (either Go or shell) is tested
and should compile and run according to Go release $<$Insert Go release
here$>$. Even though the language is still changing an effort has been
made to create "future proof" code examples.

The following convention is used throughout this book:
\begin{itemize}
\item Code is displayed in \prog{DejaVu mono};
\item Keywords are displayed in \key{DejaVu mono bold};
\item Comments are displayed in \rem{DejaVu mono italic};
\item Extra remarks in the code \coderemark{are displayed like this};
\item Longer remarks get a number - \gocircle{1} - with the explanation following;
\item Shell examples use a \pr{} as prompt.
\end{itemize}

\section{Official documentation}
The reader is assumed to have read (and somewhat understand), the
Go Tutorial \cite{go_tutorial}, and the Effective Go
document \cite{effective_go}. The
website \url{http://golang.org/doc/} is also a very good starting point
for reading up on Go.\footnote{\url{http://golang.org/doc/} itself is served by 
a Go program called \prog{godoc}.}

\begin{lbar}
\noindent Didn't read those documents? Go read them now and stop wasting your time
with this one.
\end{lbar}

\section{Getting Go}
%% Set all Go variables
% $GOOS=linux|darwin|freebsd
% $GOARCH=386|amd64
% $GOROOT
% $GOBIN
The are currently (February 2010) no packages for Go in any Linux
distribution. The route to install Go is thus slightly longer than
it should be. When Go stablizes this situation will change. For now
you need to retrieve the code from the mercurial archive and compile
Go yourself.
\begin{itemize}
\item Install Mercurial (to get the \prog{hg} command), in
Ubuntu/Debian/Fedora you must install the \prog{mercurial} package;

\item For building Go you also need the packages: \prog{bison},
\prog{gcc}, \prog{libc6-dev}, \prog{ed}, \prog{gawk} and \prog{make};

\item Then retrieve the Go source code:
\begin{display}
\pr export GOROOT=~/go
\pr hg clone -r release https://go.googlecode.com/hg/ $GOROOT
\end{display}
This will install Go in a directory named \dir{go} in your
home directory;

\item Compile Go
\begin{display}
\pr cd $GOROOT/src
\pr ./all.bash
\end{display}

\end{itemize}

\section{Online documentation}
Go comes with its own documentation in the form of a Go program called
\prog{godoc}. 
You can use it yourself to look
in the online (i.e. installed on your system) documentation. For
instance, suppose we want to know more about the package \package{hash} 
(more on packages see section \ref{sec:packages} on page
\pageref{sec:packages}). We could then give the command
\prog{godoc hash}, which will display
\begin{display}
PACKAGE

package hash
import "hash"

TYPES

type Hash interface \{
    // Write adds more data to the running ha \ldots
\end{display}
How to read this and how you can create your own package documentation
is explained in chapter \ref{chap:packages}.

\section{Origins}
Go has it origins in Plan 9 \cite{plan9} and Plan 9 is (or was 
supposed to be) the successor of Unix. As you know one of the
core ideas of Unix is "everything is a file", so the \func{read()} and
\func{write()} calls work as well on normal files as they do on I/O
devices. However for some devices this has never happened, notably
network and video devices. In Plan 9 this "everything is a file idea"
is taken to the next level and truly everything is presented to the 
user as a file. This has nothing to do with Go, but Plan 9 included
a language called Limbo \cite{limbo}. 

From the Limbo \cite{limbo} paper:
\begin{quote}
Limbo is a programming language intended for applications running
distributed systems on small computers. It supports modular programming,
strong type checking at compile- and run-time, interprocess
communication over typed channels, automatic garbage collection, and
simple abstract data types. It is designed for safe execution even on
small machines without hardware memory protection.
\end{quote}
From the looks of it, Go is an re-implementation of Limbo with adhering
to the good ideas and improving on the poorer ones. One of the niceties
of Limbo was the fact the cross-compiling was (is?) very easy. This is 
also the case in Go.

Channels (see chapter \ref{chap:channels} are also available in Limbo,
in fact the documentation states:
\begin{quote}
[a channel] is a communication mechanism capable of sending and receiving objects of
the specified type to another agent in the system. Channels may be used
to communicate between local processes; using library procedures, they
may be connected to named destinations. In either case send and receive
operations may be directed to them.
\end{quote}

An intermediate language between Limbo and Go might be Newsqueak
\cite{newsqueak}, bla bla 
Hoare \cite{hoare} and it channel communication

Communicating Sequential Processes (CSP)
\draft{I have no clue if stuff even happened like this}

\section{Exercises}
\input{ex-intro/ex-doc.tex}

\cleardoublepage
\section{Answers}
\shipoutAnswer
