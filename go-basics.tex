\epi{在 Go 中，代码说到做到。}{\textit{Go
Nuts 邮件列表}\\\textsc{ANDREW GERRAND}}
\noindent{}有一些东西使得 Go 不同于其他语言。
\begin{description}
\item[清晰并且简洁]
Go 努力保持小并且优美，你可以在短短几行代码里做许多事情。

\item[并行]
Go 让函数很容易成为\emph{非常}轻量的线程。
这些线程在 Go 中被叫做 \first{goroutines}{goroutines} 
\footnote{是的，它的发音很接近 \emph{co}routines，
但是 goroutines 确实有一些不同，我们将在 \ref{chap:channels} 章节讨论。}；
%% gofix.go:11: non-declaration statement outside function body

\item[Channel]
这些 goroutines 之间的通讯由
\first{channel}{channel} \cite{csp}\cite{hoare} 完成；

\item[快速]
编译很快，执行也很快。目标是跟 C 一样快。编译时间用秒计算；

\item[安全]
Go 有垃圾收集，在 Go 中无须 \func{free()}，语言会处理这一切；

\item[标准的格式化]
Go 程序可以被格式化为程序员希望的（几乎）任何形式，
\emph{但是}官方格式是存在的。标准也非常简单：
\prog{gofmt} 的输出就是\emph{官方}认可的格式。

\item[类型后置]
类型在变量名的\emph{后面}，像这样 \prog{var a int}，
来代替 C 中的 \prog{int a;}；

\item[UTF-8]
任何地方都是 UTF-8的，包括字符串\emph{以及}程序代码。 
你可以在代码中使用 \prog{$\Phi$ = $\Phi$ + 1}；

\item[开源]
Go 的许可证是完全开源的，查阅 Go 发布的源码中的 LICENSE 文件。

\item[开心]
用 Go 写程序会非常开心！

\end{description}
Erlang \cite{erlang} 与 Go 在部分功能上类似。
Erlang 和 Go 之间主要的区别是 Erlang 是函数式语言，而 Go 是命令式的。
Erlang 运行在虚拟机上，而 Go 是编译的。Go 用起来感觉更接近 Unix。

\section{Hello World}
\label{sec:hello world}
在 Go 指南中，用一个传统的方式展现了 Go：让它打印 "Hello World"
（Ken Thompson 和 Dennis Ritchie 在 20 世纪 70 年代，发布 C 语言的时候开创了这个先河）。
我们不认为可以做得更好，所以就是这个，Go 的 ''Hello World''。

\lstinputlisting[numbers=right,label=src:hello,caption=Hello world]{src/helloworld.go}
逐行阅读这个程序。
\showremarks

\section{编译和运行代码}
Go 编译器叫做 \verb|<数字>g|，数字是 6 表示用于 64 位 Intel 而 8 表示 32 位 Intel。
连接器用相同的命名方式：\verb|<数字>l|。在本书中，我们将使用 \prog{6g} 和 \prog{6l} 完成所有的编译。
为了编译上面的代码，执行：
\begin{display}
\pr 6g helloworld.go
\end{display}
并且用 \prog{6l} 链接它：
\begin{display}
\pr 6l helloworld.6
\end{display}

然后执行：
\begin{display}
    \pr ./6.out	    \coderemark{默认的（64位） Go 可执行文件名（32 位上是 8.out）}
\end{display}
\vspace{-3.0ex}
\texttt{Hello, world; or }%
\begin{math}\kappa\alpha\lambda\eta\mu\acute{\epsilon}\rho\alpha\hspace{1em}\kappa\end{math}%
\'o\begin{math} \sigma\mu\epsilon\end{math}\texttt{; or }こんにちは 世界
\ \newline
\ \newline

\subsection{使用 Makefile}
\label{sec:building a program}
另一种可以少折腾的（在建立好后）编译 Go 程序的办法，是使用 \file{Makefile}。
下面是用于构建 \prog{helloworld}的：
\lstinputlisting[language=make,caption=Makefile for a program,numbers=right,linerange={5,11}]{src/Makefile.prog}
行 3 指定了编译的程序的名字，而行 5 列举了源代码文件。
现在执行 \verb|make| 就可以完成你的程序编译。
留意 Go 使用了不同于 \prog{make} 的，叫做 \prog{gomake} 的命令。它是（当前来说）一个 GNU make 的小封装。
Go 程序的构建系统在将来可能会发生变化，从而将 \prog{make} 移除。所以我们使用 \prog{gomake}。
留意 \file{Makefile} 创建的可执行文件叫做 \prog{helloworld}，而不是 \prog{6.out} 或者 \prog{8.out}。

\section{变量、类型和保留字}
\label{sec:vars}
在接下来的章节中，我们将会了解这个新语言的变量、基本类型、保留字和控制流。
Go 在语法上有着类 C 的感觉。
如果你希望将两个（或更多）语句放在一行书写，它们必须用分号(';')分隔。
一般情况下，你不需要分号。

Go 同其他语言不同的地方在于变量的类型在变量名的\emph{后面}。
不是：\lstinline{int a}，而是 \lstinline{a int}。
当定义了一个变量，它默认赋值为其类型的 null 值。
这意味着，在 \lstinline{var a int}后，\lstinline{a} 的值为 0。
而 \lstinline{var s string}，意味着 \lstinline{s} 被赋值为零长度字符串，
也就是 \lstinline{""}。

在 Go 中，声明和赋值是两步的一个过程，但是可以连在一起。
比较下面作用相同的代码片段。
\index{variables!declaring}
\index{variables!assigning}

\begin{minipage}{.5\textwidth}
\begin{lstlisting}[linewidth=.5\textwidth,caption={Declaration with =}]
var a int
var b bool
a = 15
b = false
\end{lstlisting}
\hfill
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{lstlisting}[linewidth=.5\textwidth,caption={Declaration with :=}]
a := 15
b := false
\end{lstlisting}
\ \\
\ \\
\hfill
\end{minipage}

在左边使用了保留字 \key{var} 声明变量，\emph{然后}赋值给它。
右边的代码使用了 \mbox{\key{:=}{ }} 使得在一步内完成了声明和赋值
（这一形式只可用在函数\emph{内}）。
在这种情况下，变量的类型是由值\emph{推演}出来的。
值 15 表示是 \type{int} 类型，值 \texttt{false} 告诉 Go 它的类型应当是 \type{bool}。
多个 \key{var} 声明可以成组，\key{const} 和 \key{import} 同样允许这么做。
留意圆括号的使用：
\begin{lstlisting}
var (
    x int
    b bool
)
\end{lstlisting}

有相同类型的多个变量同样可以在一行内完成声明：
\lstinline{var x, y int} 让 \var{x} 和 \var{y} 都是 \type{int} 类型变量。
同样可以使用 \first{parallel assignment}{parallel assignment}：
\begin{lstlisting}
a, b := 20, 16
\end{lstlisting}
让 \var{a} 和 \var{b} 都是整数变量，并且赋值 20 给 \var{a}，16 给 \var{b}。

一个特殊的变量名是 \var{\textbf{\_}} \index{variables!\_}（下划线）\index{variables!underscore}。
任何赋给它的值都被丢弃。在这个例子中，将 35 赋值给 \var{b}，同时丢弃 34。
\begin{lstlisting}
_, b := 34, 35
\end{lstlisting}
Go 的编译器对声明却未使用的变量在报错，下面的代码会产生这个错误：
\error{声明了 i 却未使用}

\begin{lstlisting}
package main
func main() { 
    var i int
}
\end{lstlisting}

\subsection{布尔类型}
布尔类型表示由预定义的常量 \emph{true} 和 \emph{false} 代表的布尔判定值。
布尔类型是 \type{bool}。

\subsection{数字类型}
Go 有众所周知的类型如 \lstinline{int}，这个类型根据你的硬件决定适当的长度。
意味着在 32 位硬件上，是 32 位的；在 64 位硬件上是 64 位的。
注意：\lstinline{int} 是 32 或 64 位之一，不会定义成其他值。
\lstinline{uint} 情况相同。

如果你希望明确其长度，你可以使用 \lstinline{int32} 或者 \lstinline{uint32}。
完整的整数类型列表（符号和无符号）是 
\type{int8}，\type{int16}，\type{int32}，\type{int64} 和
\type{byte}，\type{uint8}，\type{uint16}，\type{uint32}，\type{uint64}。
\lstinline{byte} 是 \lstinline{uint8} 的别名。
浮点类型的值有 \lstinline{float32} 和 \lstinline{float64}
（没有 \lstinline{float} 类型）。 
64 位的整数和浮点数\emph{总是} 64 位的，即便是在 32 位的架构上。

需要留意的是这些类型全部都是独立的，并且混合用这些类型向变量赋值会引起编译器错误，
例如下面的代码：
\lstinputlisting[numbers=right,label=src:types,caption=Familiar types are still distinct]{src/types.go}
在行 7 触发一个赋值错误：

\noindent\error{types.go:7: cannot use a + a (type int)  as type int32 in assignment}

赋值可以用八进制、十六进制或科学计数法：
\lstinline{077}, \lstinline{0xFF}, \lstinline{1e3} or
\mbox{\lstinline{6.022e23}} 这些都是合法的。

\subsection{常量}
\label{sec:constants}
常量在 Go 中，也就是 constant。它们在编译时被创建，只能是数字、字符串或布尔值；
\lstinline{const x = 42} 生成 \var{x} 这个常量。可以使用 \first{\key{iota}}{keyword!iota}
\footnote{单词 [iota] 在日常英语短语 'not one iota'，意思是 '不是最小的差异'，
是来自新约中的短语："\emph{until heaven and earth pass away, not an
iota, not a dot, will pass from the Law}." \cite{iota}}
生成枚举值。
\begin{lstlisting}
const (
	a = iota
	b = iota 
)
\end{lstlisting}
第一个 \key{iota} 表示为 0，因此 \var{a} 等于 0，
当 \key{iota} 再次在新的一行使用时，它的值增加了 1，
因此 \var{b} 的值是 1。

也可以像下面这样，省略 Go 重复的 \key{= iota}：
\begin{lstlisting}
const (
	a = iota
	b	    |\coderemark{Implicitly \texttt{b = iota}}|
)
\end{lstlisting}
如果需要，可以明确指定常量的类型：
\begin{lstlisting}
const (
	a = 0           |\coderemark{Is an \key{int} now}|
	b string = "0" 
)
\end{lstlisting}

\subsection{字符串}
另一个重要的内建类型是 \lstinline{string}。赋值字符串的例子：
\begin{lstlisting}
s := "Hello World!"
\end{lstlisting}
字符串在 Go 中是 UTF-8 的由双引号 (") 包裹的字符序列。
如果你使用单引号 (') 则表示一个字符（UTF-8编码）
——这种在 Go 中\emph{不是} \lstinline{string}。

一旦给变量赋值，字符串就不能修改了：在 Go 中字符串是不可变的。
从 C 来的用户，下面的情况在 Go 中是非法的。
\begin{lstlisting}
var s string = "hello"
s[0] = 'c'  |\coderemark{修改第一个字符为 'c'，这会报错}|
\end{lstlisting}
在 Go 中实现这个，需要下面的方法：
\begin{lstlisting}
s := "hello"
c := []byte(s)	    |\longremark{转换 \var{s} 为字节数组，%
查阅在 \ref{chap:beyond} 章 "\titleref{sec:conversions}" 小节、%
页面 \pageref{sec:conversions} 的内容；}|
c[0] = 'c'	    |\longremark{修改数组的第一个元素；}|
s2 := string(c)     |\longremark{创建\emph{新的}字符串 \var{s2} 保存修改；}|
fmt.Printf("%s\n", s2) |\longremark{用 \func{fmt.Printf} 函数输出字符串。}|
\end{lstlisting}
\showremarks

\begin{lbar}[多行字符串]
基于分号的置入（查阅 \cite{effective_go} 章节 "Semicolons"），
你需要小心使用多行字符串。如果这样写：
\begin{lstlisting}
s := "Starting part"
    + "Ending part"
\end{lstlisting}
会被转换为：
\begin{lstlisting}
s := "Starting part";
    + "Ending part";
\end{lstlisting}
这是错误的语法，应当这样写：
\begin{lstlisting}
s := "Starting part" +
     "Ending part"
\end{lstlisting}
Go 就不会在错误的地方插入分号。另一种方式是使用反引号 \key{`} 作为\emph{原始}字符串符号\index{string literal!raw}：
\begin{lstlisting}
s := `Starting part
     Ending part`
\end{lstlisting}
留意最后一个例子 \var{s} 现在也包含换行。
不像\emph{转义}字符串标识 \index{string literal!interpreted} ，
原始字符串标识的值在引号内的字符是\emph{不转义}的。
\end{lbar}
\subsection{复数}
Go 原生支持复数。它的变量类型是 \lstinline{complex128}
（64 位虚数部分）。如果需要小一些的，还有 \lstinline{complex64}
——32 位的虚数部分。复数写为 \var{re + im$i$}，\var{re} 是实数部分，
\var{im} 是虚数部分，而 $i$ 是标记 '$i$' ($\sqrt{-1}$)。
使用复数的一个例子：

\lstinline{var c complex64 = 5+5i; fmt.Printf("Value is: %v", c)}\newline
将会打印：\lstinline{(5+5i)}

\section{运算符和内建函数}
Go 支持普通的数字运算符，表格 \ref{tab:op-precedence} 列出了当前支持的运算符，
以及其优先级。它们全部是从左到右结合的。

\begin{table}[H]
\begin{center}
\caption{运算优先级}
\label{tab:op-precedence}
\input{tab/precedence.tex}
\end{center}
\end{table}
\verb|+ - * /| 和 \verb|%| 会像你期望的那样工作，
\verb!& | ^!
和 \verb!&^! 分别表示位运算符\first{\key{按位与}}{operator!bitwise!and}，
\first{\key{按位或}}{operator!bitwise!or}，\first{\key{按位异或}}{operator!bit
wise xor}和\first{\key{位清除}}{operator!bitwise!clear}。
\verb|&&| 和 \verb/||/ 运算符是逻辑\first{\key{与}}{operator!and}和逻辑
\first{\key{或}}{operator!or}。表格中没有列出的是逻辑\first{\key{非}}{operator!not}：\verb/!/。

虽然 Go 不支持运算符重载（或者方法重载），而一些内建运算符却\emph{支持}重载。
例如 \texttt{+} 可以用于整数、浮点数、复数和字符串（字符串相加表示串联它们）。

\section{Go 保留字}
\begin{table}[H]
\begin{center}
\caption{Go 中的保留字}
\label{tab:keywords}
\input{tab/keywords.tex}
\end{center}
\end{table}
表格 \ref{tab:keywords} 列出了 Go 中所有的保留字。
在下面的段落和章节中会介绍它们。其中有一些已经遇到过了。
\begin{itemize}
\item \key{var} 和 \key{const} 参阅 "\titleref{sec:vars}" 在 \pageref{sec:vars} 页；
\item \key{package} 和 \key{import} 已经有过短暂的接触，在 "\titleref{sec:hello world}" 部分。 
\ref{chap:packages} 这章对其有详细的描述。
\end{itemize}
其他都有对应的介绍和章节：
\begin{itemize}
\item \key{func} 用于定义函数和方法；
\item \key{return} 用于从函数返回，\key{func} 和 \key{return}
参阅\ref{chap:functions}了解详细信息；
\item \key{go} 用于并行（\ref{chap:channels}章）；
\item \key{select} 用于选择不同类型的通讯，参阅\ref{chap:channels}章；
\item \key{interface} 参阅 \ref{chap:interfaces}；
\item \key{struct} 用于抽象数据类型，参阅\ref{chap:beyond}章；
\item \key{type} 同样参阅 \ref{chap:beyond}。
\end{itemize}

\section{控制结构}
在 Go 中只有很少的几个控制结构
\footnote{这个章节复制于 \cite{effective_go}。}。
例如这里没有 do 或者 while 循环，只有 \key{for}。
有（灵活的）\key{switch} 语句和 \key{if}，而
\key{switch} 接受像\key{for}那样可选的初始化语句。
还有叫做类型选择和多路通讯转接器的 \key{select} （参阅 \ref{chap:channels} 章节）。
语法有所不同（同 C 相比）：无需圆括号，而语句体必须\emph{总是}包含在大括号内。

\subsection{if}
在 Go 中 \first{\key{if}}{keyword!if} 看起来是这样的：
\begin{lstlisting}
if x > 0 {	|\coderemark{\{ is mandatory}|
    return y
} else {
    return x
}
\end{lstlisting}
强制大括号鼓励将简单的 \key{if} 语句写在多行上。
无论如何，这都是一个很好的形式，尤其是语句体中含有控制语句，
例如 \first{\key{return}}{keyword!return} 或者 \first{\key{break}}{keyword!break}。

\key{if} 和 \key{switch} 接受初始化语句，通常用于设置一个（局部）变量。
\begin{lstlisting}
if err := file.Chmod(0664); err != nil {  |\coderemark{\texttt{nil} is %
like C's NULL}|
    log.Stderr(err) |\coderemark{Scope of \var{err} is limited to %
\key{if}'s body}|
    return err
}
\end{lstlisting}
可以像通常那样使用逻辑运算符（参考 \ref{tab:op-precedence} 表格）：
\begin{lstlisting}
if true && true  {
    println("true")
}
if ! false {
    println("true")
}
\end{lstlisting}

在 Go 库中，你会发现当一个 \key{if} 语句不会进入下一个语句流程
——也就是说，语句体结束于 \key{break}，\key{continue}，\key{goto}
或者 \key{return}，不必要的 \first{\key{else}}{keyword!else} 会被省略。

\begin{lstlisting}
f, err := os.Open(name, os.O_RDONLY, 0)
if err != nil {
    return err
}
doSomething(f)
\end{lstlisting}
这个例子通常用于检测可能的错误序列。成功的流程一直执行到底部使代码很好读，
当遇到错误的时候就排除它。这样错误的情况结束于 \key{return} 语句，
这样就无须 \key{else} 语句。
\begin{lstlisting}
f, err := os.Open(name, os.O_RDONLY, 0)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    return err
}
doSomething(f, d)
\end{lstlisting}
下面的语法在 Go 中是非法的：
\begin{lstlisting}
if err != nil
{		    |\coderemark{必须同 if 在同一行}|
    return err
}
\end{lstlisting}
参阅 \cite{effective_go} "Semicolons" 章节了解其后更深入的原因。

\begin{lbar}[\key{if-then-else} 的结尾]
注意如果在函数中这样结束：
\begin{lstlisting}
if err != nil {
    return err
} else {
    return nil
}
\end{lstlisting}
它不会编译。这是 Go 编译器的一个 bug。
参阅 \cite{go_issue_65} 了解更多关于此问题的描述，以及可能的修复。
\end{lbar}

\subsection{goto}
Go 有 \first{\key{goto}}{keyword!goto} 语句——明智的使用它。
用 \key{goto} 跳转到一定是当前函数内定义的 \index{label} 标签。
例如假设这样一个循环：
\begin{lstlisting}
func myfunc() {
        i := 0                                                                                      
Here:	   |\coderemark{这行的第一个词，以分号结束作为标签}|
        println(i)
        i++ 
        goto Here |\coderemark{跳转}|
}
\end{lstlisting}
标签名是大小写敏感的。

\subsection{for}
\label{sec:for}
Go 的 \first{\key{for}}{keyword!for} 循环有三种形式，只有其中的一种使用分号。
\begin{lstlisting}
for init; condition; post { } |\coderemark{和 C 的 \key{for} 一样}|

for condition { }             |\coderemark{和 while 一样}|

for { }                       |\coderemark{和 C 的 \key{for(;;)} 一样（死循环）}|
\end{lstlisting}
短声明使得在循环中声明一个序号变量更加容易。
\begin{lstlisting}
sum := 0
for i := 0; i < 10; i++ {
    sum += i	|\coderemark{sum = sum + i 的简化写法}|
}   |\coderemark{\var{i} 实例在循环\emph{结束}会消失}|
\end{lstlisting}
最后，由于 Go 没有逗号表达式，而 ++ 和 -- 是语句而不是表达式，
如果你想在 \key{for} 中执行多个变量，应当使用 \first{parallel assignment}{parallel assignment}。
\begin{lstlisting}
// Reverse a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 { |\coderemark{平行赋值}|
    a[i], a[j] = a[j], a[i] |\coderemark{这里也是}|
}
\end{lstlisting}

\subsection{break 和 continue}
利用 \first{\key{break}}{keyword!break} 可以提前退出循环，\key{break} 终止当前的循环。
\begin{lstlisting}
for i := 0; i < 10; i++ {
    if i > 5 {
	break |\coderemark{终止这个循环，只打印 0 到 5}|
    }
    println(i)
}
\end{lstlisting}
循环嵌套循环时，可以在 \key{break} 后指定标签。
用标签决定\emph{哪个}循环被终止：
\begin{lstlisting}
J:  for j := 0; j < 5; j++ {
	for i := 0; i < 10; i++ {
	    if i > 5 { 
		break J	|\coderemark{现在终止的是 \var{j} 循环，而不是 \var{i} 的那个}|
	    }
	    println(i)
	}
    } 
\end{lstlisting}

利用 \first{\key{continue}}{keyword!continue} 让循环进入下一个迭代，而略过剩下的所有代码。
下面打印了 0 到 5。
\begin{lstlisting}
for i := 0; i < 10; i++ {
    if i > 5 {
	continue |\coderemark{跳过下面所有的代码}
    println(i)
}
\end{lstlisting}

\subsection{range}
保留字 \first{\key{range}}{keyword!range} 可用于循环。
它可以在 slice、array、string、map 和 channel（参阅 \ref{chap:channels} 章节）。
\key{range} 是个迭代器，当被调用的时候，从它循环的内容中返回一个键值对。
基于不同的内容，\key{range} 返回不同的东西。

当对 slice 或者 array 做循环时，\key{range} 返回序号作为键，这个序号对应的内容作为值。
考虑这个代码：\index{keyword!range!on slices}
\begin{lstlisting}
list := []string{"a", "b", "c", "d", "e", "f"}     |\longremark{创建一个字符串的 %
slice（参阅 "\titleref{sec:arrays}" 在 \pageref{sec:arrays} 页）。}|
for k, v := range list {	|\longremark{用 \key{range} 对其进行循环。%
每一个迭代，\key{range} 将返回 \type{int} 类型的序号，%
\type{string} 类型的值，以 0 和 "a" 开始。}|
    // 对 k 和 v 做想做的事情\longremark{\var{k} 的值为 0\ldots5，而 %
\var{v} 在循环从 "a"\ldots"f"。}
}
\end{lstlisting}
\showremarks

也可以在字符串上直接使用 \key{range}。
这样字符串被打散成独立的 Unicode 字符
\footnote{在 UTF-8 世界的字符有时被称作 \first{runes}{runes}。
通常，当人们讨论字符时，多数是指 8 位字符。
UTF-8 字符可能会有 32 位，称作 rune。}
并且起始位按照 UTF-8 解析。
循环：\index{keyword!range!on maps}
\begin{lstlisting}
for pos, char := range "a|$\Phi{}$|x" {
    fmt.Printf("character '%c' starts at byte position %d\n", char, pos)
}
\end{lstlisting}
打印
\begin{display}
character 'a' starts at byte position 0
character '\begin{math}\Phi\end{math}' starts at byte position 1
character 'x' starts at byte position 3 \coderemark{\begin{math}\Phi\end{math} took 2 bytes}
\end{display}

\subsection{switch}
Go's \first{\key{switch}}{keyword!switch} is very flexible. The expressions need
not be
constants or even integers, the cases are evaluated top to bottom until
a match is found, and if the \key{switch} has no expression it switches on
\type{true}. It's therefore possible -- and idiomatic -- to write an
\key{if-else-if-else} chain as a \key{switch}.
\begin{lstlisting}
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
\end{lstlisting}
There is no automatic fall through, you can however use
\first{\key{fallthrough}}{keyword!fallthrough} to make do just that.
Without \key{fallthrough}:
\begin{lstlisting}
switch i {
    case 0:  // empty case body
    case 1:
	f()  // f is not called when i == 0!
}
\end{lstlisting}
And with:
\begin{lstlisting}
switch i {
    case 0:  fallthrough
    case 1:
	f()  // f is called when i == 0!
}
\end{lstlisting}
With \first{\key{default}}{keyword!default} you can specify an action
when none of the other cases match.
\begin{lstlisting}
switch i {
    case 0:  
    case 1:
	f()
    default:	
	g()	// called when i is not 0 or 1
}
\end{lstlisting}

Cases can be presented in comma-separated lists.
\begin{lstlisting}
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+': |\coderemark{, as "or"}|
        return true
    }
    return false
}
\end{lstlisting}

Here's a comparison routine for byte arrays that uses two \key{switch} statements:
\begin{lstlisting}
// Compare returns an integer comparing the two byte arrays
// lexicographically.
// The result will be 0 if a == b, -1 if a < b, and +1 if a > b
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    // String are equal except for possible tail
    switch {
    case len(a) < len(b):
        return -1
    case len(a) > len(b):
        return 1
    }
    return 0	// Strings are equal
}
\end{lstlisting}

\section{内建函数}
预定义了少数函数，这意味着\emph{无需}引用任何包就可以使用它们。
表格 \ref{tab:predef-functions} 列出了所有的内建函数。

\begin{table}[H]
\begin{center}
\caption{Pre--defined functions in Go}
\label{tab:predef-functions}
\input{tab/functions.tex}
\end{center}
\end{table}

\paragraph{\func{close} and \func{closed}} are used in
channel communication and the closing of those channels, see chapter \ref{chap:channels}
for more on this.
\index{built-in!close}\index{built-in!closed}

\paragraph{\func{len} and \func{cap}} are used on a number of different
types, \func{len} is
used for returning the length of strings and the length of slices and
arrays. See section "\titleref{sec:arrays}" for the details of slices and
arrays and the function
\func{cap}.\index{built-in!len}\index{built-in!cap}

\paragraph{\func{new}} is used for allocating memory for user defined
data types. See section "\titleref{sec:allocation with new}" on page
\pageref{sec:allocation with new}.
\index{built-in!new}

\paragraph{\func{make}} is used for allocating memory for built-in
types (maps, slices and channels). See section 
"\titleref{sec:allocation with make}" on page
\pageref{sec:allocation with make}.
\index{built-in!make}

\paragraph{\func{copy}} is used for copying slices. \func{append} is 
for concatenating slices. See section "\titleref{sec:slices}" in this
chapter.
\index{built-in!copy}
\index{built-in!append}

\paragraph{\func{panic} and \func{recover}} are used for an 
\emph{exception} mechanism. See the section "\titleref{sec:panic}" on 
page \pageref{sec:panic} for more.
\index{built-in!panic}
\index{built-in!recover}

\paragraph{\func{print} and \func{println}} are low level printing
functions that can be used without reverting to the
\package{fmt}\index{package!fmt}
package. These are mainly used for debugging.
\index{built-in!print}\index{built-in!println}

\paragraph{\func{complex}, \func{real} and \func{imag}} all deal with
\first{complex numbers}{complex numbers}. Other than the simple example
we gave, we will not further explain complex numbers.
\index{built-in!complex}
\index{built-in!real}
\index{built-in!imag}


\section{Arrays, slices and maps}
\label{sec:arrays}
Storing multiple values in a list can be done by utilizing arrays, or
their more flexible cousin: slices. A dictionary or hash type is also
available, it is called a \type{map} in Go.

\subsection{Arrays}
An array is defined by: \verb|[n]<type>|, where $n$ is the length
of the array and \verb|<type>| is the stuff you want to store.
Assigning, or indexing an element in the array is done with square
brackets:
\begin{lstlisting}
var arr [10]int
arr[0] = 42
arr[1] = 13
fmt.Printf("The first element is %d\n", arr[0])
\end{lstlisting}
Array types like \lstinline{var arr = [10]int} have a fixed size. The
size is \emph{part} of the type.
They can't grow, because then they would have a different type. Also arrays
are values: Assigning one array to another \emph{copies} all the elements.
In particular, if you pass an array to a function, it will receive a
copy of the array, not a pointer to it. 

\index{array!multidimensional}
To declare an array you can use the following: \lstinline{var a [3]int},
to initialize it to something else than zero, use a \first{composite
literal}{composite literal}: \lstinline|a := [3]int{1, 2, 3}| and
this can be shortened to \lstinline|a := [...]int{1, 2, 3}|, where Go counts
the elements automatically. \gomarginpar{A composite literal allows you
to assign a value directly to an array, slice or map.}
Note that all fields must be specified.  So if you are using multidimensional
arrays you have to do quite some typing:
\begin{lstlisting}
a := [2][2]int{ [2]int{1,2}, [2]int{3,4} }
\end{lstlisting}
Which is the same as:
\begin{lstlisting}
a := [2][2]int{ [...]int{1,2}, [...]int{3,4} }
\end{lstlisting}
When declaring arrays you \emph{always} have to type something in
between the square brackets, either a number or three dots (\verb|...|)
when using a composite literal. 
\gomarginpar{Go \gorelease{2010-10-27} \cite{go_release_hist}.} 
Since \gorelease{2010-10-27} this syntax was further simplified.
From the release notes:
\begin{quote}
The syntax for arrays, slices, and maps of composite literals has been
simplified. Within a composite literal of array, slice, or map type, elements
that are themselves composite literals may elide the type if it is identical to
the outer literal's element type. 
\end{quote}
This means our example can become:
\begin{lstlisting}
a := [2][2]int{ {1,2}, {3,4} }
\end{lstlisting}

\subsection{Slices}
\label{sec:slices}
A slice is similar to an array, but it can grow when new elements
are added.
A slice always refers to an underlaying array. What makes slices different
from
arrays is that a slice is a pointer \emph{to} an array;
slices are \first{reference types}{reference types}, 
\gomarginpar{Reference types are created with \lstinline{make}.}
which means that if you assign one slice to
another, both refer to the same underlying array. For instance, if a
function takes a slice argument, changes it makes to the elements of the
slice will be visible to the caller, analogous to passing a pointer to
the underlying array. With:
\begin{lstlisting}
sl := make([]int, 10)
\end{lstlisting}
you create a slice which can hold ten elements. Note that the
underlaying array isn't specified.
A slice is always coupled to an array that has
a fixed size. For slices we define a \first{capacity}{slice!capacity} and a
\first{length}{slice!length}. \index{array!length}\index{array!capacity}
Figure \ref{fig:array-vs-slice} depicts the following Go code.
First we create an array of $m$ elements of the type \lstinline{int}:
\lstinline{var array[m]int}\newline
Next, we create a slice from this array:
\lstinline{slice := array[0:n]}\newline
And now we have:
\begin{itemize}
\item{\lstinline{len(slice) == n == cap(slice) == n}{} ;}
\item{\lstinline{len(array) == cap(array) == m}{} .}
\end{itemize}
\begin{figure}[H]
\caption{Array versus slice}
\label{fig:array-vs-slice}
\begin{center}
\includegraphics[scale=0.65]{fig/array-vs-slice.pdf}
\end{center}
\end{figure}

Given an array, or another slice, a new slice is created via
\lstinline{a[I:J]}. This creates a new slice which refers to 
\lstinline{a}, starts at index \var{I}, and ends
before index \var{J}. It has length \lstinline{J - I}.

\begin{lstlisting}
// array[n:m], create a slice from array with elements n to m-1
a := [...]int{1, 2, 3, 4, 5} |\longremark{Define an array with 5 %
elements, from index 0 to 4;}|
s1 := a[2:4] |\longremark{Create a slice with the elements from index 2 %
to 3, this contains: \texttt{3, 4};}|
s2 := a[1:5] |\longremark{Create a slice with the elements from index 1 %
to 4, contains: \texttt{2, 3, 4, 5};}|
s3 := a[:]   |\longremark{Create a slice with all the elements of the %
array in it. This is a shorthand for: \texttt{a[0:len(a)]};}|
s4 := a[:4]  |\longremark{Create a slice with the elements from index %
0 to 3, this is thus short for: \texttt{a[0:4]}, and yields: \texttt{1, 2, %
3, 4};}|
s5 := s2[:]  |\longremark{Create a slice from the slice \var{s2}, note that %
\texttt{s5} still refers to the array \texttt{a}.}|
\end{lstlisting}
\showremarks

In the code listed in \ref{src:arrays} we dare to do the impossible on
line 8 and try to allocate something
beyond the capacity (maximum length of the underlaying array) and
we are greeted with a \emph{runtime} error.
\lstinputlisting[numbers=right,label=src:arrays,caption=Arrays and slices]{src/array-and-slices.go}
If you want to extend a slice, there are a couple of built-in functions
that make life easier:
\lstinline{append} and \lstinline{copy}. From \cite{go_spec}:
\begin{quote}
The function \lstinline{append} appends zero or more values \lstinline{x} to a
slice \lstinline{s} and returns the resulting slice, with the same type as
\lstinline{s}.
If the capacity of \lstinline{s} is not large enough to fit the additional values,
\lstinline{append} allocates a new, sufficiently large slice that fits both the
existing slice elements and the additional values. Thus, the returned
slice may refer to a different underlying array.
\end{quote}
\index{built-in!append}
\begin{lstlisting}
s0 := []int{0, 0}
s1 := append(s0, 2)       |\longremark{append a single element, \texttt{s1 == []int\{0, 0, 2\}};}|
s2 := append(s1, 3, 5, 7) |\longremark{append multiple elements, %% 
\texttt{s2 == []int\{0, 0, 2, 3, 5, 7\}};}|
s3 := append(s2, s0...)   |\longremark{append a slice, \texttt{s3 == []int\{0, 0, 2, 3, 5, 7, 0, 0\}}. %%
Note the three dots!}|
\end{lstlisting}
\showremarks
And
\begin{quote}
The function \lstinline{copy} copies slice elements from a source
\lstinline{src} to a
destination \lstinline{dst} and returns the number of elements copied. Source and
destination may overlap. The number of arguments
copied is the minimum of \lstinline{len(src)} and
\mbox{\lstinline{len(dst)}}.
\end{quote}
\index{built-in!copy}
\begin{lstlisting}
var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
n1 := copy(s, a[0:])    |\coderemark{\texttt{n1 == 6, s == []int\{0, 1, 2, 3, 4, 5\}}}|
n2 := copy(s, s[2:])    |\coderemark{\texttt{n2 == 4, s == []int\{2, 3, 4, 5, 4, 5\}}}|
\end{lstlisting}

\subsection{Maps}
\label{sec:maps}
Many other languages have a similar type built-in, Perl has hashes,
Python has its dictionaries and C++ also has maps (in
\package{lib}\index{package!lib}) for instance. 
In Go we have the
\first{\key{map}}{keyword!map} type. A \type{map} can be thought of as an array indexed by
strings (in its most simple form).
In the following listing we define a \type{map} which converts from a
\lstinline{string} (month abbreviation) to an \lstinline{int} -- the number of days in that month. 
The generic way to define a map is with: \verb|map[<from type>]<to type>|

\begin{lstlisting}
monthdays := map[string]int{
	"Jan": 31, "Feb": 28, "Mar": 31, 
	"Apr": 30, "May": 31, "Jun": 30, 
	"Jul": 31, "Aug": 31, "Sep": 30, 
	"Oct": 31, "Nov": 30, "Dec": 31, |\coderemark{The comma here is required}|
}		    
\end{lstlisting}
Note to use \lstinline{make} when only declaring a \lstinline{map}:
\lstinline|monthdays := make(map[string]int)|

For indexing (searching) in the map, we use square brackets, for example
suppose we want to print the
number of days in December: \lstinline{fmt.Printf("%d\n", monthdays["Dec"])}\newline
If you are looping over an array, slice, string, or map a
\first{\key{range}}{keyword!range}
clause help you again, which returns the key and corresponding value
with each invocation.\index{keyword!range!on maps}
\begin{lstlisting}
year := 0
for _, days := range monthdays {    |\coderemark{Key is not used, hence \texttt{\_, days}}|
    year += days
}
fmt.Printf("Numbers of days in a year: %d\n", year)
\end{lstlisting}
Adding elements to the \type{map} \index{keyword!map!add elements} would be done as:
\begin{lstlisting}
monthdays["Undecim"] = 30	|\coderemark{Add a month}|
monthdays["Feb"]     = 29	|\coderemark{Overwrite entry - for leap years}|
\end{lstlisting}
To test for existence \index{keyword!map!existence}, you would use the
following\cite{go_course_day2}:
\begin{lstlisting}
var value int
var present bool

value, present = monthdays["Jan"] |\coderemark{If exist, \texttt{present} has the value \key{true}}|
                                 |\coderemark{Or better and more Go like}|
v, ok := monthdays["Jan"]	 |\coderemark{Hence, the "comma ok" form}|
\end{lstlisting}
And finally you can remove elements \index{keyword!map!remove elements} from the \type{map}:
\begin{lstlisting}
monthdays["Mar"] = 0, false       |\coderemark{Deletes "Mar", always rains anyway}|
\end{lstlisting}
Which looks a bit like the reverse of the "comma ok" form.

\section{Exercises}
\input{ex-basics/ex-for.tex}

\input{ex-basics/ex-fizzbuzz.tex}

\input{ex-basics/ex-strings.tex}

\input{ex-basics/ex-average-no-func.tex}

\cleardoublepage
\section{Answers}
\shipoutAnswer
