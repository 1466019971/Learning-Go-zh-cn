\epi{我总是兴奋于阳光的轻抚和沉寂在早期编程语言中。
无需太多文字；许多已经完成了。
旧的程序阅读起来就像是同表达良好的研究工作者或受到良好训练的机器同事沟通一样，
而不是与编译器争论。谁愿意让其成熟到发出这样的声音呢？
}{\textsc{RICHARD P. GABRIEL}}

\noindent{}函数是构建 Go 程序的基础部件；所遇有趣的事情都是在它其中发生的。
函数的定义看起来像这样：
\input{fig/function.tex}
\showremarks
这里有两个例子，左边的函数没有返回值，右边的只是简单的将输入返回。

\begin{minipage}{.5\textwidth}
\begin{lstlisting}
func subroutine(in int) {
    return
}
\end{lstlisting}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{lstlisting}
func identity(in int) int {
    return in
}
\end{lstlisting}
\end{minipage}

可以随意安排函数定义的顺序，编译器会在执行前扫描每个文件。所以函数原型在 Go 中都是过期的旧物。
Go 不允许函数嵌套。
然而你可以利用匿名函数实现它，参阅本章的 "\titleref{sec:functions as values}" 在
\pageref{sec:functions as values} 页。


递归函数跟其他语言是一样的：
\begin{lstlisting}[caption=递归函数]
func rec(i int) {
   if i == 10 {
        return
   }
   rec(i+1)
   fmt.Printf("%d ", i)
}
\end{lstlisting}
这会打印 \texttt{9 8 7 6 5 4 3 2 1 0}。

\section{作用域}
在 Go 中，定义在函数外的变量是\first{全局}{scope!local}的，
那些定义在函数内部的变量，对于函数来说是\first{局部}{scope!local}的。
如果命名覆盖——一个局部变量与一个全局变量有相同的名字——在函数执行的时候，
局部变量将覆盖全局变量。

\begin{minipage}{.5\textwidth}
\input{fig/scope1.tex}
\hfill
\vfill
\end{minipage}
\hfill
\begin{minipage}{.5\textwidth}
\input{fig/scope2.tex}
\hfill
\vfill
\end{minipage}

在 \ref{src:scope1} 中定义了函数 \func{q()} 的局部变量 \var{a}。
局部变量 \var{a} 仅在 \func{q()} 中可见。这也就是为什么代码会打印：\texttt{656}。
在 \ref{src:scope2} 中没有定义局部变量，只有全局变量 \var{a}。
这将使得赋值全局可见。这段代码将会打印：\texttt{655}。

在下面的例子中，我们在 \func{f()} 中调用 \func{g()}：

\lstinputlisting[caption=当函数调用函数时的作用域]{src/scope3.go}

输出内容将是：\texttt{565}。\emph{局部}变量\emph{仅仅}在执行定义它的函数时有效。
%%Finally, one can create a \first{"function literal"}{function literal} in which you essentially 
%%define a function inside another
%%function, i.e. a \first{nested function}{nested function}. 
%%The following figure should clarify why it prints: \texttt{565757}. 
%%\input{fig/scope3.tex}

\section{多个返回值}
\label{sec:multiple return}
Go 一个非常特别的特性是函数和方法可以返回多个值（Python 也可以）。
这可以用于改进一大堆在 C 程序中糟糕的惯例用法：
修改参数的方式，返回一个错误（例如遇到 \texttt{EOF} 则返回 -1）。
在 Go 中，\lstinline{Write} 返回一个计数值和一个错误：
"是的，你写入了一些字节，但是由于设备异常，并不是全部都写入了。"。
\package{os} 包中的 \lstinline{*File.Write} 是这样声明的：
\begin{lstlisting}
func (file *File) Write(b []byte) (n int, err Error)
\end{lstlisting}
如同文档所述，它返回写入的字节数和一个非 \lstinline{nil} 的 \var{Error}
当 \lstinline{n != len(b)}。
这是 Go 中常见的样式。

类似的方法避免了传递指针模拟引用参数来返回值。
这里有个样例函数，从字节数组的指定位上取得数值，返回这个值和下一个位置。
\begin{lstlisting}
func nextInt(b []byte, i int) (int, int) {
    x := 0
    // 假设所有的都是数字
    for ; i < len(b); i++ {
        x = x*10 + int(b[i])-'0'
    }
    return x, i
}
\end{lstlisting}
你可以在输入的数组中扫描数字，像这样：
\begin{lstlisting}
a := []byte{'1', '2', '3', '4'}
var x int
for i := 0; i < len(a); {	|\coderemark{没有 \texttt{i++}}|
    x, i = nextInt(a, i)
    println(x)
}
\end{lstlisting}
没有元组作为原生类型，多返回值可能是最佳的选择。
你可以精确的返回希望的值，而无须重载域空间到特定的错误信号上。

\section{命名返回参数}
\label{sec:named result parameters}
Go 函数的返回值或者结果参数可以指定一个名字，并且像原始的变量那样使用，就像输入参数那样。
如果对其命名，在函数开始时，它们会用其类型的零值初始化；如果函数在不加参数的情况下执行了
\key{return} 语句，结果参数的当前值会作为返回值返回。
用这个特性，允许（再一次的）用较少的代码做更多的事
\footnote{这是 Go 的格言："用\emph{更少}的代码做\emph{更多}的事"。}。

名字不是强制的，但是它们可以使得代码更加健壮和清晰：
\emph{这是文档}。
如果命名 \lstinline{nextInt} 的 \type{int} 返回值哪个代表哪个。

\begin{lstlisting}
func nextInt(b []byte, pos int) (value, nextPos int) { /* ... */ }
\end{lstlisting}
由于命名结果会被初始化并关联于无修饰的 \key{return}，
它们可以非常简单并且清晰。这里有一个 \lstinline{io.ReadFull} 的版本，很好的运用了它：

\begin{lstlisting}
func ReadFull(r Reader, buf []byte) (n int, err os.Error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:len(buf)]
    }
    return
}
\end{lstlisting}
在下面的例子中，定义了一个简单的函数，用于计算
\gomarginpar{这一节的部分内容来自 \cite{go_intro}。}  % layout
值 \var{x} 的阶乘。
\begin{lstlisting}
func Factorial(x int) int { |\coderemark{\texttt{func Factorial(x int) (int)} 同样也行}|
   if x == 0 {
      return 1
   } else {
      return x * Factorial(x - 1)
   }
}
\end{lstlisting}
所以，也可以将函数编写为：
\begin{lstlisting}
func Factorial(x int) (result int) {
  if x == 0 {
    result = 1	
  } else {
    result = x * Factorial(x - 1)
  }
  return
}
\end{lstlisting}
当命名了返回值，代码变得健壮并且易读。
同样也可以编写一个多返回值的函数：
\begin{lstlisting}
func fib(n) (val, pos int) { |\coderemark{都是 int}|
   if n == 0 {
      val = 1
      pos = 0
   } else if n == 1 {
      val = 1
      pos = 1
   } else {
      v1, _ := fib(n-1)
      v2, _ := fib(n-2)
      val = v1 + v2
      pos = n
   }
   return
}
\end{lstlisting}

\section{延迟的代码}
\label{sec:deferred code}
假设有一个函数，打开文件并且对其进行若干读写。在这样的函数中，经常有提前返回的地方。
如果你这样做，就需要关闭正在工作的文件描述符。这经常导致产生下面的代码：
\begin{lstlisting}[caption=没有 defer]
func ReadWrite() bool {
    file.Open("file")
    // 做一些工作
    if failureX {
	file.Close()
	return false
    }

    if failureY {
	file.Close()
	return false
    }
    file.Close()
    return true
}
\end{lstlisting}
在这里有许多重复的代码。为了解决这些，Go 有了
\first{\key{defer}}{keyword!defer} 语句。在 \key{defer}
后指定的函数会在函数退出\emph{前}调用。

上面的代码可以被改写为下面这样。这使得函数更加可读、健壮，将
\func{Close} 对应的放置于 \func{Open} 后。
\begin{lstlisting}[caption=With defer]
func ReadWrite() bool {
    file.Open("file")
    defer file.Close()	|\coderemark{\func{file.Close()} \emph{是}函数}|
    // Do your thing
    if failureX {
	return false    |\coderemark{\func{Close()} 现在自动调用}|
    }
    if failureY {
	return false    |\coderemark{这里也是}|
    }
    return true
}
\end{lstlisting}

可以将多个函数放入"延迟列表"\index{deferred list}中，这个例子来自 \cite{effective_go}：
\begin{lstlisting}
for i := 0; i < 5; i++ { 
    defer fmt.Printf("%d ", i) 
} 
\end{lstlisting}
延迟的函数是按照后进先出（LIFO）的顺序执行，所以上面的代码打印：
\lstinline{4 3 2 1 0}。

利用 \func{defer} 甚至可以修改返回值，假设正在使用命名结果参数和函数符号
\index{function!literal}\footnote{函数符号也就是被叫做\index{closure}闭包的东西。}，例如：
\begin{lstlisting}[caption=函数符号]
defer func() {
	/* ... */
}()		 |\coderemark{() 在这里是必须的}|
\end{lstlisting}
或者这个例子，更加容易了解为什么，以及在哪里需要括号：
\begin{lstlisting}[caption=带参数的函数符号]
defer func(x int) {
	/* ... */
}(5)		 |\coderemark{为输入参数 \var{x} 赋值 5}|
\end{lstlisting}
在这个（匿名）函数中，可以访问任何命名返回参数：
\begin{lstlisting}[caption=在 defer 中访问返回值]
func f() (ret int) {    |\coderemark{\var{ret} 初始化为零}|
	defer func() {
		ret++	|\coderemark{\var{ret} 增加为 1}|
	}()
	return 0	|\coderemark{返回的是 1 而\emph{不是} 0！}|
}
\end{lstlisting}

\section{Variadic parameters}
Functions that take variadic parameters are functions that have a
variable number of parameters. To do this, you first
need to declare your function to take variadic arguments:
\begin{lstlisting}
func myfunc(arg ...int) {}
\end{lstlisting}
The \lstinline{arg ... int} instructs Go to see this as a function that
takes a variable number of arguments. Note that these arguments all
have the type \type{int}. Inside your function's body the variable
\var{arg} is a slice of ints:
\begin{lstlisting}
for _, n := range arg {
    fmt.Printf("And the number is: %d\n", n)
}
\end{lstlisting}
If you don't specify the type of the variadic argument it defaults to the
empty interface \var{interface\{\}} (see chapter
\ref{chap:interfaces}").
Suppose we have another variadic function called \func{myfunc2}, the 
following example shows how to pass the variadic arguments to it:
\begin{lstlisting}
func myfunc(arg ...int) {
    myfunc2(arg...)  |\coderemark{Pass it as-is}|
    myfunc2(arg[:2]...)  |\coderemark{Slice it}|
}
\end{lstlisting}

\section{Functions as values}
\label{sec:functions as values}
\index{function!as values}
\index{function!literals}
As with almost everything in Go, functions are also \emph{just} values.
They can be assigned to variables as follows:
\lstinputlisting[label=src:anonfunc,caption=Anonymous function,linerange={3,}]{src/anon-func.go}
If we use \lstinline{fmt.Printf("%T\n", a)} to print the type of
\var{a}, it prints \func{func()}.

Functions--as--values may also be used in other places, like in maps.
Here we convert from integers to functions:
\begin{lstlisting}[caption=Functions as values in maps]
var xs = map[int]func() int{
    1: func() int { return 10 },
    2: func() int { return 20 },
    3: func() int { return 30 }, |\coderemark{Mandatory ,}|
    /* ... */
}
\end{lstlisting}
Or you can write a function that takes a function as its parameter, for
example a \func{Map} function that works on \type{int} slices. This is
left as an exercise for the reader, see exercise Q\ref{ex:map function}
on page \pageref{ex:map function}.

\section{Callbacks and closures}
\label{sec:callbacks}
With functions as values they are easy to pass to functions, from where
they can be used as callbacks. First define a function that
does "something" with an integer value:
\begin{lstlisting}
func printit(x int) {       |\coderemark{Function returns nothing}|
    fmt.Print("%v\n", x)    |\coderemark{Just print it}|

}
\end{lstlisting}
The signature of this function is: \lstinline{func printit(int)}, or
without the function name: \mbox{\lstinline{func(int)}}. To create a new function
that uses this one as a callback we need to use this signature:
\begin{lstlisting}
func callback(y int, f func(int)) { |\coderemark{\func{f} will hold the function}|
    f(y)    |\coderemark{Call the callback \func{f} with \var{y}}|
}
\end{lstlisting}
We've already seen some use of closures in section "\titleref{sec:deferred code}", but there
is more to tell. When you define a closure, i.e. when you start using a function
literal you still have access to the (local) variables defined in the current
function.

\begin{lstlisting}
// Define some local vars
// This code is WAY to complex, but illustrates it nicely
    frameSquare := func(x, y int) {
            // closure effortlessly passes local variables to callback
            if thickFrame {
                    // draw 3 x 3 pixel block for thicker rectangle
                    for x0 := x - 1; x0 <= x+1; x0++ {
                            for y0 := y - 1; y0 <= y+1; y0++ {
                                    rgba.Set(x0, y0, redColor)
                            }
                    }
            } else {
                    rgba.Set(x, y, blueColor)
            }
    }
\end{lstlisting}

If you want to do this by \emph{not} using a closure and defining a completely new
function you need to pass all vars to the function.
\todo{Gist is there, but needs much better wording and code}



\section{Panic and recovering}
\label{sec:panic}
Go does not have a exception mechanism, like that in Java for instance: you can not throw exceptions.
Instead it using a panic-and-recover mechanism. It is worth remembering that you should use this as
a last resort, your code will not look, or be, better if it is littered with panics. It's a powerful tool:
use it wisely. So, how do you use it.

The following description was taken from \cite{go_blog_panic}:
\begin{description}
\item[Panic]{is a built-in function that stops the ordinary flow of control and begins panicking. When the function 
\func{F} calls \key{panic},
execution of \func{F} stops, any deferred functions in \func{F} are executed normally, and 
then \func{F} returns to its caller. To the caller, \func{F} then
behaves like a call to \key{panic}. The process continues up the stack until all functions in the current 
goroutine have returned, at which point the program crashes. 

Panics can be initiated by invoking \func{panic} directly. They can also be caused by \emph{runtime errors}, such
as out-of-bounds array accesses.}

\item[Recover]{is a built-in function that regains control of a panicking goroutine. Recover is \emph{only} useful inside 
\emph{deferred} functions.

During normal execution, a call to \func{recover} will return \type{nil} and have no other effect. 
If the current goroutine is panicking, a call
to \func{recover} will capture the value given to \func{panic} and resume normal execution.}
\end{description}

\section{Exercises}
\input{ex-functions/ex-average.tex}

\input{ex-functions/ex-order.tex}

\input{ex-functions/ex-scope.tex}

\input{ex-functions/ex-stack.tex}

\input{ex-functions/ex-vararg.tex}

\input{ex-functions/ex-fib.tex}

\input{ex-functions/ex-map.tex}

\input{ex-functions/ex-minmax.tex}

\input{ex-functions/ex-bubblesort.tex}

\input{ex-functions/ex-funcfunc.tex}

\cleardoublepage
\section{Answers}
\shipoutAnswer
