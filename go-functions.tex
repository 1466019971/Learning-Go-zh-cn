\epi{I'm always delighted by the light touch and stillness of
early programming languages.  Not much text; a lot gets
done. Old programs read like quiet conversations
between a well-spoken research worker and a well-
studied mechanical colleague, not as a debate with a
compiler.  Who'd have guessed sophistication bought
such noise?}{Dick Gabriel}

\noindent{}Functions are the basic building blocks in Go programs; all interesting
stuff happens in them. A function is declared as follows:
\input{fig/function.tex}
\showremarks

A function without a return value:
\begin{lstlisting}
func subroutine(in int) {
    return
}
\end{lstlisting}

The following is a rather simple function that returns it's input:
\begin{lstlisting}
func identity(in int) int {
    return in
}
\end{lstlisting}
You cannot declare functions in functions. 
\begin{lstlisting}
func a() {
    println("Hello from a()")
    func b() {			    |\coderemark{Illegal nesting}|
	println("Hello from b()")    
    }
}
\end{lstlisting}
In others words nested functions are not allowed in Go. However you can 
work around this by using anonymous functions (see section
"\titleref{sec:functions as values}" on page \pageref{sec:functions as values} 
in this chapter).

\section{Scope}
Variables declared outside any functions are global in Go, those
defined in functions are local to those functions. If names overlap --- a
local variable is declared with the same name as a global one --- the
local variables masks the global one for the duration (XXX is this true) 
of the function.

\begin{minipage}{.5\textwidth}
\input{fig/scope1.tex}
\hfill
\vfill
\end{minipage}
\begin{minipage}{.5\textwidth}
\input{fig/scope2.tex}
\hfill
\vfill
\end{minipage}

In listing \ref{src:scope1} we introduce a local variable \var{a}
in the function \func{q()}
This local \var{a} is only visible in \func{q()}. That is
why the code will print: \texttt{656}.
In listing \ref{src:scope2} no new variables are introduced, there
is only a global \var{a}.
Assigning a new value to it is globally visible. This code will
print: \texttt{655}

\key{return} is a statement, not a function, so the parentheses around
any arguments are not needed.

\section{Multiple return values}
\label{sec:multiple return}
One of Go's unusual features is that functions and methods can return multiple
values. This can be used to improve on a couple of clumsy idioms in C programs:
in-band error returns (such as -1 for EOF) and modifying an argument.

In C, a write error is signaled by a negative count with the error code
secreted away in a volatile location. In Go, \lstinline{Write} can return a count and an
error: "Yes, you wrote some bytes but not all of them because you filled the
device". The signature of \lstinline{*File.Write} in package
\package{os} is:
\begin{lstlisting}
func (file *File) Write(b []byte) (n int, err Error)
\end{lstlisting}
and as the documentation says, it returns the number of bytes written and a
non-\lstinline{nil} Error when \lstinline{n != len(b)}. This is a common style

A similar approach obviates the need to pass a pointer to a return value to
simulate a reference parameter. Here's a simple-minded function to grab a
number from a position in a byte array, returning the number and the next
position.
\begin{lstlisting}
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ {
        x = x*10 + int(b[i])-'0'
    }
    return x, i
}
\end{lstlisting}
You could use it to scan the numbers in an input array a like this:
\begin{lstlisting}
    for i := 0; i < len(a); {
        x, i = nextInt(a, i)
        fmt.Printf("%d", x)
    }
\end{lstlisting}

\section{Named result parameters}
The return or result "parameters" of a Go function can be given names and used
as regular variables, just like the incoming parameters. When named, they are
initialized to the zero values for their types when the function begins; if the
function executes a \key{return} statement with no arguments, the current values of
the result parameters are used as the returned values.

The names are not mandatory but they can make code shorter and clearer:
\emph{they are documentation}. 
If we name the results of \lstinline{nextInt} it becomes obvious which
returned \type{int} is which.

\begin{lstlisting}
func nextInt(b []byte, pos int) (value, nextPos int) {
\end{lstlisting}
Because named results are initialized and tied to an unadorned
\key{return},
they can simplify as well as clarify. Here's a version of
\lstinline{io.ReadFull} that uses them well:

\begin{lstlisting}
func ReadFull(r Reader, buf []byte) (n int, err os.Error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:len(buf)]
    }
    return
}
\end{lstlisting}

In the following example we declare a simple function which calculates
\gomarginpar{Some text in this chapter comes from \cite{go_intro}.}  % layout
the factorial value of a value \var{x}.

\begin{lstlisting}
func Factorial(x int) int { |\coderemark{\texttt{func Factorial(x int) (int)} is also OK}|
   if x == 0 {
      return 1;	
   } else {
      return x * Factorial(x - 1);
   }
}
\end{lstlisting}

Go extends that by adding support for named return values. You can 
\gomarginindex{named return values}{named return values}
declare the return value as a variable in the function header; then you
can assign values to that variable. When the function returns, the last
value assigned to the return variable is the return value. So you could
also write factorial as:

\begin{lstlisting}
func Factorial(x int) (result int) {
  if x == 0 {
    result = 1;	
  } else {
    result = x * Factorial(x - 1);
  }
  return;
}
\end{lstlisting}
You can also write a function with multiple return values:

\begin{lstlisting}
func fib(n) (val int, pos int) {
   if n == 0 {
      val = 1;
      pos = 0;
   } else if n == 1 {
      val = 1;
      pos = 1;
   } else {
      v1, _ := fib(n-1);
      v2,_ := fib(n-2);
      val = v1 + v2;
      pos = n;
   }
   return;
}
\end{lstlisting}
(The above contained boneheaded mistake 1: I just wrote that out, and didn't bother to compile it. Naturally, I screwed it up in a silly way. It's since been fixed.)

\section{Deferred code}
Suppose you have a function in which you open a file and perform various
writes and reads on it. In such a function there are often spots where
you want to return early. If you do you need to close the file
descriptor you are working on. This often leads to the following code:
\begin{lstlisting}[caption=Without \func{defer}]
function ReadWrite() bool {
    file.Close("lll")
    // Do you thing
    if failureX {
	file.Close("lll")
	return false
    }

    if failureY {
	file.Close("lll")
	return false
    }
    file.Close("lll")
    return true
}
\end{lstlisting}
Where a lot of code is repeated with a good reason. To overcome this ---
and do more in less code --- Go has the \func{defer} statement. After
\func{defer} you specify a function which is called just \emph{before} a
return from the function is executed.

The above code could be rewritten with it as follows, making the whole
function more readable \emph{and} shorter.
\begin{lstlisting}[caption=With \func{defer}]
function ReadWrite() bool {
    defer func() {	    |\coderemark{Anonymous function}|
	file.Close("lll")
    }()			    |\coderemark{() is necessary}|
    // Do you thing
    if failureX {
	return false
    }

    if failureY {
	return false
    }
    return true
}
\end{lstlisting}

\section{Variadic parameters}
Functions that take variadic parameters are functions that have a
variable number of parameters or in other words, optionals parameters.

\section{Functions as values}
\label{sec:functions as values}
As with almost everything in Go, functions are also \emph{just} values,
so they can be assigned to variables. Like so:
\lstinputlisting[label=src:anonfunc,caption=Anonymous function]{src/anon-func.go}


\section{Exercises}
\input{ex-functions/ex-stack.tex}

\input{ex-functions/ex-stack-package.tex}

\input{ex-functions/ex-calc.tex}

\input{ex-functions/ex-vararg.tex}

\input{ex-functions/ex-fib.tex}

\cleardoublepage
\section{Answers}
\shipoutAnswer
