<<<<<<< HEAD
\begin{Exercise}[title={接口和编译},difficulty=1]
\Question
在第 \pageref{src:interface fail} 页的代码 \ref{src:interface fail} 
编译正常——就像文中开始描述的那样。但是当运行的时候，会得到运行时错误，
因此有些东西\emph{有}错误。为什么代码编译没有问题呢？
=======
\begin{Exercise}[title={Interfaces and compilation},difficulty=1]
\Question
The code in listing \ref{src:interface fail} on page
\pageref{src:interface fail} compiles OK --- as stated 
in the text. But when you run it you'll get a runtime error, so
something \emph{is} wrong. Why does the code compile cleanly then?
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
\end{Exercise}

\begin{Answer}
\Question
<<<<<<< HEAD
代码能够编译是因为整数类型实现了空接口，这是在编译时检查的。

修复这个正确的途径是测试这个空接口可以被转换，如果可以，调用对应的方法。
\ref{src:interface empty} 列出的 Go 代码中定义了函数 \func{g}——这里重复一下：
=======
The code compiles because an integer type implements the empty interface
and that is the check that happens at compile time.

A proper way to fix this is to test if such an empty interface can
be converted and, if so, call the appropriate method. The Go code
that defines the function \func{g} in listing \ref{src:interface empty}
-- repeated here:
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
\begin{lstlisting}
func g(any interface{}) int { return any.(I).Get() }
\end{lstlisting}

<<<<<<< HEAD
\noindent{}应当修改为：
\begin{lstlisting}
func g(any interface{}) int {
    if v, ok := any.(I); ok {	// 检查是否可以转换
	return v.Get()		// 如果可以，调用 Get()
    }
    return -1			// 随便返回个什么
}
\end{lstlisting}
如果现在调用 \func{g()}，就不会有运行时错误了。在 Go 中这种用法被称作``comma ok''。
=======
\noindent{}Should be changed to become:
\begin{lstlisting}
func g(any interface{}) int {
    if v, ok := any.(I); ok {	// Check if any can be converted
	return v.Get()		// If so invoke Get()
    }
    return -1			// Just so we return anything
}
\end{lstlisting}
If \func{g()} is called now there are no run-time errors anymore. The
idiom used is called ``comma ok'' in Go.
>>>>>>> 9d3c4dbbba2dd6ce9e8c33dbfcbd0d7ca7842eb7
\end{Answer}
