\epi{我对外科手术般进入我的身体总是有恐惧。你知道我说的是什么。}{\textit{eXistenZ}\\\textsc{TED PIKUL}}
\noindent{}
\gomarginpar{下面的内容来自 \cite{go_interfaces}。是 Ian Lance Taylor 编写的，他是 Go 的作者之一。}
在 Go 中，保留字 \first{\emph{interface}}{interface} 被赋予了多种不同的含义。
每个类型都有接口，意味着对那个类型\emph{定义了方法集合}
\index{interface!set of methods}。这段代码定义了具有一个字段和两个方法的结构类型 \type{S}。
\begin{lstlisting}[caption=定义结构和结构的方法,label=src:interface object]
type S struct { i int }
func (p *S) Get() int { return p.i }
func (p *S) Put(v int) { p.i = v }
\end{lstlisting}
也可以定义\first{接口类型}{interface!type}，仅仅是方法的集合。
这里定义了一个有两个方法的接口 \type{I}：
\begin{lstlisting}
type I interface {
  Get() int
  Put(int)
}
\end{lstlisting}
\begin{lbar}
接口类型就是方法的集合。
\end{lbar}

\noindent对于接口 \type{I}，\type{S} 是合法的\emph{实现}，因为它定义了 \type{I}
所需的两个方法。注意，即便是没有明确定义 \type{S} 实现了 \type{I}，这也是正确的。

Go 程序可以利用这个特点来实现接口的另一个含义，就是
\first{接口值}{interface!value}:

\begin{lstlisting}
func f(p I) {  |\longremark{定义一个函数接受一个接口类型作为参数；}|
    fmt.Println(p.Get()) |\longremark{\var{p} 实现了接口 \type{I}，\emph{必须}有 \func{Get()} 方法；}|
    p.Put(1) |\longremark{\func{Put()} 方法是类似的。}|
}
\end{lstlisting}
\showremarks
这里的变量 \var{p} 保存了接口类型的值。因为
\type{S} 实现了 \type{I}，可以调用 \func{f} 向其传递 \type{S} 类型的值的指针：
\begin{lstlisting}
var s S; f(&s)
\end{lstlisting}

获取 \type{s} 的地址，而不是 \type{S} 的值的原因，是因为在 \type{s} 
的指针上定义了方法，参阅上面的代码 \ref{src:interface object}。
这并不是必须的——可以定义让方法接受值——但是这样的话 \func{Put} 方法就不会像期望的那样工作了。

实际上，无须明确一个类型是否实现了一个接口意味着 Go 实现了叫做
\first{duck typing}{duck typing}\cite{duck_typing} 的模式。
这不是纯粹的 duck typing，因为如果可能的话 Go 编译器将对类型是否实现了接口进行实现静态检查。
然而，Go 确实有纯粹动态的方面，如可将一个接口类型转换到另一个。
通常情况下，转换的检查是在运行时进行的。
如果是非法转换——当在已有接口值中存储的类型值不匹配将要转换到的接口——程序会抛出运行时错误。

在 Go 中的接口有着与许多其他编程语言类似的思路：
C++ 中的纯抽象虚基类，Haskell 中的 typeclasses 或者 Python 中的 duck typing。
然而没有其他任何一个语言联合了接口值、静态类型检查、运行时动态转换，以及无须明确定义类型适配一个接口。
这些给 Go 带来的结果是，强大、灵活、高效和容易编写的。

\subsection{到底是什么？}
来定义另外一个类型同样实现了接口 \type{I}：
\begin{lstlisting}[caption=实现了 I 的另一个类型]
type R struct { i int }
func (p *R) Get() int { return p.i }
func (p *R) Put(v int) { p.i = v }
\end{lstlisting}
函数 \func{f} 现在可以接受 \type{R} 个 \type{S} 类型的变量。
假设需要在函数 \func{f} 中知道实际的类型。在 Go 中可以使用
 \first{type switch}{type switch} 得到。

\begin{lstlisting}
func f(p I) {
    switch t := p.(type) { |\longremark{类型判断。在 \key{switch} 语句中使用 \key{(type)}。保存类型到变量 \var{t}；}|
        case *S: |\longremark{\var{p} 的实际类型是 \type{S} 的指针；}|
        case *R: |\longremark{\var{p} 的实际类型是 \type{R} 的指针；}|
        case S:  |\longremark{\var{p} 的实际类型是 \type{S}；}|
        case R:  |\longremark{\var{p} 的实际类型是 \type{R}；}|
        default: |\longremark{实现了 \type{I} 的其他类型。}|
    }
}
\end{lstlisting}
\showremarks
注意，得到接口变量的类型的唯一方法是使用类型判断。
在 \key{switch} 外使用 \key{(type)} 是非法的。

\subsection{空接口}
由于每个类型都能匹配到空接口：
\type{interface\{\}}。我们可以创建一个接受空接口作为参数的普通函数：
\begin{lstlisting}[caption=空接口参数的函数t,label=src:interface empty]
func g(any interface{}) int { 
    return any.(I).Get() 
}
\end{lstlisting}
在这个函数中的 \lstinline{return any.(I).Get()} 是有一点窍门的。
值 \var{any} 具有类型 \type{interface\{\}}，这意味着方法没有任何约束：
它能包含任何类型。\lstinline{.(I)} 是 \first{类型断言}{type assertion}，用于转换 \var{any} 到
\type{I} 类型的接口。如果有这个类型，则可以调用 \func{Get()} 函数。
因此，如果创建一个 \type{*S} 类型的新变量，也可以调用 \func{g()}，
因为 \type{*S} 同样实现了空接口。
\begin{lstlisting}
s = new(S)
fmt.Println(g(s));
\end{lstlisting}
调用 \func{g} 的运行不会出问题，并且将打印 0。如果调用 \func{g()} 的参数没有实现 \type{I} 
会带来一个麻烦：
\begin{lstlisting}[caption=接口实现异常,label=src:interface fail]
i := 5		|\coderemark{声明 i 是一个"该死的" \texttt{int}}|
fmt.Println(g(i))
\end{lstlisting}
这能通过编译，但是当运行的时候会得到：

\noindent\error{panic: interface conversion: int is not main.I: missing
method Get}

\noindent{}这是绝对没问题，内建类型 \type{int} 没有 \func{Get()} 方法。

\subsection{检查接口}
在代码中，希望避免这类错误，Go 提供了检查一个变量是否实现了某个接口的方法，
同样使用了类型断言，但是这回是在 \key{if} 语句中。

\begin{lstlisting}
if ok := any.(I); ok { 
   /* 对于实现接口 I 的任意操作 */
} 
\end{lstlisting}

\section{方法}
方法就是有接收者的函数（参阅第 \ref{chap:functions} 章）。

可以在任意类型上定义方法（除了非本地类型，包括内建类型：\type{int} 类型不能有方法）。
然而可以新建一个拥有方法的整数类型。例如：
\begin{lstlisting}
type Foo int

func (self Foo) Emit() {
  fmt.Printf("%v", self)
}

type Emitter interface {
  Emit()
}
\end{lstlisting}
对那些非本地（定义在其他包的）类型也一样：
% Empty line here is critical, otherwise no new paragraph is created

\begin{minipage}{.5\textwidth}
\begin{lstlisting}[linewidth=.7\textwidth,caption=扩展内建类型错误]
func (i int) Emit() {
  fmt.Printf("%d", i)
}
\end{lstlisting}
\noindent\error{不能定义新的方法\\ 在非本地类型 int 上}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{lstlisting}[caption=扩展非本地类型错误]
func (a *net.AddrError) Emit() {
  fmt.Printf("%v", a)
}
\end{lstlisting}
\noindent\error{不能定义新的方法\\ 在非本地类型 net.AddrError 上}
\end{minipage}

\paragraph{}  %% needed otherwise the minipage flows over

\subsection{接口类型的方法}
接口定义为一个方法的集合。方法包含实际的代码。
换句话说，一个接口就是定义，而方法就是实现。
因此，接收者不能定义为接口类型，这样做的话会引起
\error{invalid receiver type ...} 的编译器错误。来自语言说明书 \cite{go_spec} 的权威内容：
\begin{quote}
接收者类型必须是 \type{T} 或 \type{*T}，这里的 \type{T} 是类型名。
\type{T} 叫做接收者基础类型或简称基础类型。基础类型一定不能使指针或接口类型，
并且定义在与方法相同的包中。
\end{quote}

\subsection{接口指针}
在 Go 中创建指向接口的指针是无意义的。
\todo{接口不是指针，不是引用类型}
\gomarginpar{Go \gorelease{2010-10-13}.} 实际上创建指向接口值的指针是非法的。
发布日志中的描述使得没有任何余地怀疑这个：
\begin{quote}
语言的改变是使用指针指向接口值不再自动反引用指针。指向接口值的指针通常是低级的错误，而不是正确的代码。
\end{quote}
这来自 \cite{go_faq}。如果不是这个限制，这个代码：
\begin{lstlisting}
var buf bytes.Buffer
io.Copy(buf, os.Stdin)
\end{lstlisting}
就会复制标准输入到 \var{buf} 的副本，而不是 \var{buf} 本身。
这看起来永远不会是一个期望的结果。

\section{接口名字}
根据规则，单方法接口命名为方法名加上 \emph{-er} 后缀：Read\emph{er}，Writ\emph{er}，Formatt\emph{er} 等。

有一堆这样的命名，高效的反映了它们职责和包含的函数名。
\func{Read}，\func{Write}，\func{Close}，\func{Flush}，\func{String} 等等有着规范的声明和含义。
为了避免混淆，除非有类似的声明和含义，否则不要让方法与这些重名。
相反的，如果类型实现了与众所周知的类型相同的方法，那么就用相同的名字和声明；
将字符串转换方法命名为 \func{String} 而不是 \func{ToString}。
\gomarginpar{文本复制于 \cite{effective_go}。}

\section{简短的例子}
\label{sec:a sorting example}
回顾那个冒泡排序的练习（Q\ref{ex:bubble}），对整型数组排序：
\begin{lstlisting}
func bubblesort(n []int) {
    for i := 0; i < len(n)-1; i++ {
	for j := i + 1; j < len(n); j++ {
	    if n[j] < n[i] {
		    n[i], n[j] = n[j], n[i]
	    }
	}
    }
}
\end{lstlisting}
排序字符串的版本是类似的，除了函数的声明：
\begin{lstlisting}
func bubblesortString(n []string) { /* ... */ }
\end{lstlisting}
基于此，可能会需要两个函数，每个类型一个。而通过使用接口可以让这个变得更加通用 \index{generic}。

Lets create a new function that will sort both strings and
integers, something along the lines of this non-working example:
\begin{lstlisting}
func sort(i []interface{}) { |\longremark{Our function will receive a slice of %
empty interfaces;}|
    switch i.(type) {        |\longremark{Using a type switch we find out what the %
actual type is of the input;}|
	case string:         |\longremark{And then sort accordingly;}|
	    // ...
	case int:
	    // ...
    }
    |\longremark{Return the sorted slice.}|
}
\end{lstlisting}
\showremarks
But when we call this function with \lstinline|sort([]int{1, 4, 5})|, it
fails with:
\error{cannot use i (type []int) as type []interface { } in function argument}

This is because Go can not easily convert to a \emph{slice} of interfaces.
Just converting to an interface is easy, but to a slice is much more costly.
To keep a 
\gomarginpar{The full mailing list discussion on this subject
can be found at \cite{go_nuts_interfaces}.}
long story short: Go does not (implicitly) convert slices for you.

So what is the Go way of creating such a "generic" function? 
Instead of doing the type inference our selves with a type switch, we let
Go do it implicitly:
The following steps are required:
\begin{enumerate}
\item Define an interface type (called \type{Sorter} here) with a number of 
methods needed for sorting.
We will at least need a function to get the length of the slice,
a function to compare two values and a swap function;
\begin{lstlisting}
type Sorter interface {
    Len() int           |\coderemark{\texttt{len()} as a method}|
    Less(i, j int) bool |\coderemark{\texttt{p[j] $<$ p[i]} as a method}|
    Swap(i, j int)      |\coderemark{\texttt{p[i], p[j] = p[j], p[i]} as a method}|
}
\end{lstlisting}
\item Define new types for the slices we want to sort. Note that we
declare slice types;
\begin{lstlisting}
type Xi []int
type Xs []string
\end{lstlisting}
\item Implementation of the methods of the \type{Sorter} interface.
For integers:
\begin{lstlisting}
func (p Xi) Len() int               { return len(p) }
func (p Xi) Less(i int, j int) bool { return p[j] < p[i] }
func (p Xi) Swap(i int, j int)      { p[i], p[j] = p[j], p[i] }
\end{lstlisting}
And for strings:
\begin{lstlisting}
func (p Xs) Len() int               { return len(p) }
func (p Xs) Less(i int, j int) bool { return p[j] < p[i] }
func (p Xs) Swap(i int, j int)      { p[i], p[j] = p[j], p[i] }
\end{lstlisting}
\item Write a \emph{generic} Sort function that works on the \type{Sorter} interface.
\begin{lstlisting}
func Sort(x Sorter) { |\longremark{\var{x} is now of the \texttt{Sorter} type;}|
    for i := 0; i < x.Len() - 1; i++ { |\longremark{Using the defined functions, we implement Bubblesort.}|
	for j := i + 1; j < x.Len(); j++ {
	    if x.Less(i, j) {
		x.Swap(i, j)
	    }
	}
    }
}
\end{lstlisting}
\showremarks
\end{enumerate}
We can now use you generic \func{Sort} function as follows:
\begin{lstlisting}
ints := Xi{44, 67, 3, 17, 89, 10, 73, 9, 14, 8}
strings := Xs{"nut", "ape", "elephant", "zoo", "go"}

Sort(ints)
fmt.Printf("%v\n", ints)
Sort(strings)
fmt.Printf("%v\n", strings)
\end{lstlisting}

\section{Introspection}
\label{sec:introspection}
In a program, you can discover the dynamic type of an interface variable
by using a \key{switch}.
Such a type assertion\gomarginindex{Type assertion.}{type assertion} uses
the syntax of a type assertion with the keyword \key{type} inside the
parentheses. If the switch declares a variable in the expression, the
variable will have the corresponding type in each clause.
\begin{lstlisting}[caption=Dynamically find out the type]
package main
type PersonAge struct { |\longremark{First we define two structures as a new type, %
\texttt{PersonAge};}|
	name string
	age  int
}

type PersonShoe struct { |\longremark{And \texttt{PersonShoe};}|
	name     string
	shoesize int
}

func main() {
	p1 := new(PersonAge)
	p2 := new(PersonShoe)
	WhichOne(p1)
	WhichOne(p2)
}

func WhichOne(x interface{}) { |\longremark{This function must accept \emph{both} %
types as valid input, so we use the empty Interface, which every type implements;}|
	switch t := x.(type) { |\longremark{The type switch: \texttt{(type)};}|
	case *PersonAge:	|\longremark{When allocated with \func{new}, it's a %
pointer. So we check for \type{*PersonAge}. If \func{WhichOne()} was %
called with a non pointer value, we should check for \type{PersonAge}.}|
		println("Age person")
	case *PersonShoe:
		println("Shoe person")
	}
}
\end{lstlisting}
\showremarks

The following is another example of performing a type switch, but this
time checking for more (built-in) types:
\begin{lstlisting}[caption=A more generic type switch]
switch t := interfaceValue.(type) { |\coderemark{The type switch}|
case bool:
    fmt.Printf("boolean %t\n", t)
case int:
    fmt.Printf("integer %d\n", t)
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t)
case *int:
    fmt.Printf("pointer to integer %d\n", *t)
default:
    fmt.Printf("unexpected type %T", t)  // \%T prints type
}
\end{lstlisting}

\subsection{Introspection and reflection}
\label{subsec:introspection and reflection}
In the following example we want to look at the "tag" (here named
"namestr") defined in the
type definition of \type{Person}. To do this we need the
\package{reflect}\index{package!reflect} package (there is no other way in Go). Keep in mind
that looking at a tag means going back the \emph{type} definition. So
we use the \package{reflect} package to figure out the type of the variable
and \emph{then} access the tag.

\input{fig/reflection.tex}
\showremarks

%% look at layout
To make the difference between looking a types and values more clear,
that a look at the following code:
\begin{lstlisting}[caption=Reflection and the type and value]
func show(i interface{}) {
    switch t := i.(type) {
      case *Person:
        r := reflect.NewValue(i) |\coderemark{Enter the world of reflection}|
	tag := |\longremark{Here we want to get the "tag", which means %
going for the type. Thus we need\newline\lstinline{Elem().Type().(*reflect.StructType)} to get to it;}|
	  r.(*reflect.PtrValue).Elem().Type().(*reflect.StructType).Field(0).tag
	nam := |\longremark{Now we want to get access to the %
\emph{value} of one of the members and we %
employ\newline\lstinline{Elem().(*reflect.StructValue)} to get to it. %
Now we have arrived at the structure. Then we go the the first field %
\lstinline{Field(0)}, tell \package{reflect} is a %
\var{*reflect.StringValue} and invoke the \lstinline{Get()} method on %
it. %
\begin{figure}[H] %
\hskip3\baselineskip\parbox{0.7\textwidth}{\caption[Peeling away the layers using reflection]{Peeling away the %
layers using reflection. %
Going from a \type{*Person} via \mbox{\type{*reflect.PtrValue}} using the %
methods described in \prog{godoc reflect} to get the %
actual \type{string} contained deep within.}} %
\label{fig:reflection} %
\begin{center} %
\includegraphics[scale=0.75]{fig/reflection.pdf} %
\end{center}\end{figure} %
Reflection works by peeling off layers once you have got your hands %
on a \type{Value} in the reflection world.}|
	  r.(*reflect.PtrValue).Elem().(*reflect.StructValue).Field(0).|\newline|(*reflect.StringValue).Get()
    }
}
\end{lstlisting}
\showremarks

Setting a value works similarly as getting a value, but only works on
\emph{exported} members. Again some code:

\begin{minipage}{.5\textwidth}
\begin{lstlisting}[caption=Reflect with private member]
type Person struct {
 name string "namestr"
 age  int
}

func Set(i interface{}) {
 switch t := i.(type) {
 case *Person:
  r := reflect.NewValue(i)
  r.(*reflect.PtrValue).Elem().
    (*reflect.StructValue).
    FieldByName("name").
    (*reflect.StringValue).
    Set("Albert Einstein")
  }
}
\end{lstlisting}
\end{minipage}
\hspace{2em}
\begin{minipage}{.5\textwidth}
\begin{lstlisting}[caption=Reflect with public member]
type Person struct {
 Name string "namestr" |\coderemark{}|
 age  int
}

func Set(i interface{}) {
 switch t := i.(type) {
 case *Person:
  r := reflect.NewValue(i)
  r.(*reflect.PtrValue).Elem().
   (*reflect.StructValue).
   FieldByName("Name"). |\coderemark{}|
   (*reflect.StringValue).
   Set("Albert Einstein")
  }
}
\end{lstlisting}
\end{minipage}
The code on the left compiles and runs, but when you run it, you are greeted with a
stack trace and a \emph{runtime} error:

\noindent\error{panic: cannot set value obtained via unexported struct
field}

\noindent{}The code on the right works OK and sets the member \var{Name}
to "Albert Einstein". Of course this only works when you call \func{Set()}
with a pointer argument.

\section{Exercises}
\input{ex-interfaces/ex-interfaces.tex}

\input{ex-interfaces/ex-pointers-and-reflect.tex}

\input{ex-interfaces/ex-minmax.tex}

\cleardoublepage
\section{Answers}
\shipoutAnswer
