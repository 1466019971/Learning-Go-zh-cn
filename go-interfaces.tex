One of the interesting aspects of the Go language is \first{interface} objects.
\gomarginpar{The following text is copied (and slightly shortend) from \cite{go_interfaces} which is
written by Ian Lance Taylor - one of the original authors of Go.}
In Go, the word interface is overloaded to mean several different
things. Every type has an interface, which is the set of methods defined for
that type. This bit of code defines a struct type \type{S} with one field, and
defines two methods for \type{S}.
\begin{lstlisting}
type S struct { i int }
func (p *S) Get() int { return p.i }
func (p *S) Put(v int) { p.i = v }
\end{lstlisting}
You can also define an \first{interface type}, which is simply a set of methods.
This defines an interface \type{I} with two methods:
\begin{lstlisting}
type I interface {
  Get() int;
  Put(int);
}
\end{lstlisting}
\type{S} is a valid implementation for \type{I}, because it defines the two 
methods which \type{I} requires. Note that this is true even though there is 
no explicit declaration that \type{S} implements \type{I}. A Go program can use 
this fact via yet another meaning of interface, which is an \first{interface value}:

\begin{lstlisting}
func f(p I) { fmt.Println(p.Get()); p.Put(1) }
\end{lstlisting}
Here the variable \var{p} holds a value of interface type. Because
\type{S}
implements \type{I}, we can call \func{f} passing in a pointer to a value of type
\type{S}:

\begin{lstlisting}
var s S; f(&s)
\end{lstlisting}
The reason we need to take the address of \type{S}, rather than a value of type
\type{S}, is because we defined the methods on \type{S} to operate on pointers. This
is not a requirement - we could have defined the methods to take
values — but then the \func{Put} method would not work as expected.

The fact that you do not need to declare whether a type implements an
interface means that Go implements a form of \first{duck typing}. This is not
pure duck typing, because when possible the Go compiler will statically
check whether the type implements the interface. However, Go does have a
purely dynamic aspect, in that you can convert from one interface type
to another. In the general case, that conversion is checked at runtime.
If the conversion is invalid — if the type of the value stored in the
existing interface value does not satisfy the interface to which it is
being converted — the program will fail with a runtime error.

Interfaces in Go are similar to ideas in several other programming languages:
pure abstract virtual base classes in C++; typeclasses in Haskell; duck typing
in Python; etc. That said, I’m not aware of any other language which combines
interface values, static type checking, dynamic runtime conversion, and no
requirement for explicitly declaring that a type satisfies an interface. The
result in Go is powerful, flexible, efficient, and easy to write.

\section{Empty interface}
For example, since every type satisfies the empty interface
\type{interface \{\}}:
\begin{lstlisting}
func g(i interface{}) int { return i.(I).Get() }
func h() {
  var s S;
  fmt.Println(g(&s));
  fmt.Println(g(s)); // will fail at runtime
}
\end{lstlisting}
The first call to \func{g} will work fine and will print 0. The second call will fail
at runtime; when using \prog{gccgo}, the program will print
\begin{display}
panic: interface conversion failed: no 'Get' method
\end{display}
This is because, as discussed above, a value of type \type{S} rather than \type{*S} 
does not have any methods.

%% hier anders
So, how does this work? I will describe the current \prog{gccgo} implementation. The
implementation used in the \prog{6g/8g} compiler is generally similar but is different
in important respects.

\section{Methods on ... interfaces?}

To make that even better, methods aren't limited to objects. In fact, Go
doesn't really have objects. Any value, any type at all, can have methods. So
you can make an integer type with its own methods. For example:

\begin{lstlisting}
type Foo int;

func (self Foo) Emit() {
  fmt.Printf("\%v", self);
}

type Emitter interface {
  Emit();
}
\end{lstlisting}

%%%%%%%%% old
There are no generics in Go. A lot of people consider this a "good
%% ------------
\gomarginpar{There is discussion on this. Maybe
something will change in the future. For now we have \key{interfaces}.}
%% ------------
thing"$^\mathtt{TM}$, but it does mean you need to be a little bit 
clever on how pass arbitrary types to functions. This is 
where \first{interfaces} come in.

\section{Reflection}
TODO? Appropiate section??


A \key{switch} can also be used to discover the dynamic type of an interface
variable. Such a type switch\gomarginindex{\emph{type switch}}{type switch} uses
the syntax of a type assertion with the keyword type inside the
parentheses. If the switch declares a variable in the expression, the
variable will have the corresponding type in each clause.


Dynamically found out the type we are dealing wtih
\input{src/reflect.go}

\showremarks

%% uitproberen
\begin{lstlisting}
switch t := interfaceValue.(type) { |\coderemark{Yes, you need to type \texttt{(type)}}|
default:
    fmt.Printf("unexpected type %T", t)  // \%T prints type
case bool:
    fmt.Printf("boolean %t\n", t)
case int:
    fmt.Printf("integer %d\n", t)
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t)
case *int:
    fmt.Printf("pointer to integer %d\n", *t)
}
\end{lstlisting}


\section{Exercises}
\input{ex-interfaces/ex-cat.tex}

Make the stack impl. you create integers AND strings and whatever

TODO:
%% reflection
%% structures repeat it here, add tags

\cleardoublepage
\section{Answers}
\shipoutAnswer
