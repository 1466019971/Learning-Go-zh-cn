\epi{Go 有指针，但是没有指针运算。你不能用指针变量遍历字符串的各个字节。
}{\textit{Go For C++
Programmers}\\{\textsc{GO AUTHORS}}}
\noindent{}
Go 有指针。然而却没有指针运算，因此它们更象是引用而不是你所知道的来自于 C 的指针。
指针非常有用。
在 Go 中调用函数的时候，得记得变量是\emph{值传递}的。
因此，为了修改一个传递\emph{入}函数的值的效率和可能性，有了指针。

跟 C 中一样，用类型前的 '\key{*}' 定义一个指针：
\lstinline{var p *int}。现在 \var{p} 是一个指向整数值的指针。
所有新定义的变量都被赋值为其类型的零值，而指针也一样。
一个新定义的或者没有任何指向的指针，有值 \first{nil}{nil}。
在其他语言中，这经常被叫做空（NULL）指针，在 Go 中就是 \var{nil}。
让指针指向某些内容，可以使用\first{取址操作符}{operator!address-of}
（\func{\&}），像第 5 行那样：
\begin{lstlisting}[caption=Use of a pointer,label=src:pointers]
var p *int
fmt.Printf("%v", p) |\coderemark{打印 \var{nil}}|

var i int	    |\coderemark{定义一个整形变量 \var{i}}|
p = &i		    |\coderemark{使得 \var{p} 指向 \var{i}}|

fmt.Printf("%v", p) |\coderemark{打印出来的内容类似 \var{0x7ff96b81c000a}}|
\end{lstlisting}

更简单来说：\var{*X} 是指向 \type{X} 的指针；\var{[3]X} 是有三个 \type{X} 的数组。
因此类型更加容易从类型变化的名称上来理解：
\type{[]} 定义了 slice；
'\key{*}'
定义了指针；
\type{[size]} 定义了数组。因此 \type{[]*[3]*X} 是一个 slice，
元素是指向有三个元素的数组的指针，数组元素是指向 \type{X} 的指针。
（参阅 \ref{fig:pointers}）。
\begin{figure}[h]
\caption[Pointers and types]{指针和类型，值 \var{v} 全部为 \type{X} 类型}
\label{fig:pointers}
\begin{center}
\includegraphics[scale=0.65]{fig/pointers.pdf}
\end{center}
\end{figure}

从指针获取值是通过在指针变量前置'\type{*}'实现的：
\begin{lstlisting}[caption=获取指针指向的值,label=src:deref]
p = &i			|\coderemark{获取 \var{i} 的地址}|
*p = 8			|\coderemark{修改 \var{i} 的值}|
fmt.Printf("%v\n", *p)  |\coderemark{打印 8}|
fmt.Printf("%v\n", i)	|\coderemark{同上}|
\end{lstlisting}

前面已经说了，没有指针运算，所以如果这样写：
\lstinline{*p++}，它表示 \lstinline{(*p)++}：首先获取指针指向的值，然后对这个值加一。
\index{operator!increment}


\section{内存分配}
Go 有垃圾收集，意味着无须担心内存分配和回收。当然，自从 1980 以来几乎所有语言都有这个，
但是在类 C 语言中看到垃圾收集感觉还是很好。

Go 有两个内存分配原语，\key{new} 和 \key{make}。它们应用于不同的类型，做不同的工作，
可能有些迷惑人，但是规则很简单。
下面的章节展示了在 Go 中如何处理内存分配，并且希望能够让
\first{\key{new}}{built-in!new} 和 \first{\key{make}}{built-in!make} 之间的区别更加清晰。

\subsection{用 new 分配内存}
\label{sec:allocation with new}
内建函数 \key{new} 本质上说跟其他语言中的同名函数功能一样：
\func{new(T)} 分配了零值填充的 \type{T} 类型的内存空间，并且返回其地址，
一个 \type{*T} 类型的值。用 Go 的术语说，它返回了一个指针，指向新分配的类型 \type{T}
的零值。有一点非常重要：
\begin{lbar}
\key{new} 返回\emph{指针}。
\end{lbar}

这意味着使用者可以用 \key{new} 创建一个数据结构的实例并且可以直接工作。
如 \func{bytes.Buffer} 的文档所述“Buffer 的零值是一个准备好了的空缓冲。”
类似的，\func{sync.Mutex} 也没有明确的构造函数或 Init 方法。取而代之，
\func{sync.Mutex} 的零值被定义为非锁定的互斥量。

零值是非常有用的。例如这样的类型定义，\pageref{sec:defining your own}
页的 "\titleref{sec:defining your own}" 内容。
\begin{lstlisting}
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
\end{lstlisting}
\type{SyncedBuffer} 的值在分配内存或定义之后立刻就可以使用。在这个片段中，
\var{p} 和 \var{v} 都可以在没有任何更进一步处理的情况下工作。
\begin{lstlisting}
p := new(SyncedBuffer)  |\coderemark{Type *SyncedBuffer}|
var v SyncedBuffer      |\coderemark{Type  SyncedBuffer}|
\end{lstlisting}

\subsection{用 make 分配内存}
\label{sec:allocation with make}
回到内存分配。内建函数 \func{make(T, args)} 与 \func{new(T)} 有着不同的功能。
它只能创建 slice，map 和 channel，并且返回一个有初始值（非零）的 \type{T} 类型，
而不是 \type{*T}。本质来讲，
导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。
例如，一个 slice，是一个包含指向数据（内部 array）的指针，长度和容量的三项描述符；
在这些项目被初始化之前，slice 为 \type{nil}。对于 slice，map 和 channel，
\key{make} 初始化了内部的数据结构，填充适当的值。

\begin{lbar}
\key{make} 返回初始化后的（非零）\emph{值}。
\end{lbar}

例如，
\lstinline{make([]int, 10, 100)}
分配了 100 个整数的数组，然后用长度 10 和容量 100 创建了 slice 
结构指向数组的前 10 个元素。
区别是，\lstinline{new([]int)} 返回指向新分配的内存的指针，
而零值填充的 slice 结构是指向 \type{nil} 的 slice 值。

这个例子展示了 \key{new} 和 \key{make} 的不同。
\begin{lstlisting}
var p *[]int = new([]int)       // 分配 slice 结构内存；*p == nil
				// 已经可用
var v  []int = make([]int, 100) // v 指向一个新分配的有 100 个整数的数组。

// 不必要的复杂例子：
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// 更常见：
v := make([]int, 100)
\end{lstlisting}
务必记得 \key{make} 仅适用于 map，slice 和 channel，并且返回的不是指针。
应当用 \key{new} 获得特定的指针。

\subsection{构造函数与复合声明}
有时零值不能满足需求，必须要有一个用于初始化的构造函数，例如这个来自
\package{os} 包的例子。
\begin{lstlisting}
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
\end{lstlisting}
有许多冗长的内容。可以使用复合声明使其更加简洁，每次只用一个表达式创建一个新的实例。

\begin{lstlisting}
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}	|\coderemark{Create a new \type{File}}|
    return &f			|\coderemark{Return the address of \var{f}}|
}
\end{lstlisting}
返回本地变量的地址没有问题；在函数返回后，相关的存储区域仍然存在。

事实上，从复合声明获取分配的实例的地址更好，因此可以最终将两行缩短到一行。
\footnote{从复合声明中获取地址，意味着告诉编译器在堆中分配空间，而不是栈中。}
\begin{lstlisting}
return &File{fd, name, nil, 0}
\end{lstlisting}
联合声明中所有的字段都必须按顺序全部写上。然而，通过对元素用字段:值成对的标识，
初始化内容可以按任意顺序出现，并且可以省略初始化为零值的字段。因此可以这样

\begin{lstlisting}
return &File{fd: fd, name: name}
\end{lstlisting}
在特定的情况下，如果复合声明不包含任何字段，它创建特定类型的零值。
表达式 \lstinline{new(File)} 和 \lstinline|&File{}| 是等价的。

复合声明同样可以用于创建 array，slice 和 map，通过指定适当的索引和 map 键来标识字段。
在这个例子中，无论是 \var{Enone}，\var{Eio} 还是 \var{Einval} 初始化都能很好的工作，只要确保它们不同就好了。
\begin{lstlisting}
ar := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
sl := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
ma := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
\end{lstlisting}

\section{定义自己的类型}
\label{sec:defining your own}
自然，Go 允许定义新的类型，通过保留字
\first{\key{type}}{keyword!type} 实现： 
\begin{lstlisting}
type foo int
\end{lstlisting}
创建了一个新的类型 \lstinline{foo} 作用跟 \lstinline{int} 一样。
创建更加复杂的类型需要用到 \first{\key{struct}}{keyword!struct} 保留字。
这有个在一个数据结构中记录某人的姓名（\type{string}）和年龄（\type{int}），
并且使其成为一个新的类型的例子：
\lstinputlisting[label=src:struct,caption=Structures]{src/struct.go}
通常，\lstinline{fmt.Printf("%v\n", a)} 的输出是
\begin{display}
&\{Pete 42\}
\end{display}
这很棒！Go 知道如何打印结构。如果仅想打印某一个，或者某几个结构中的字段，
需要使用 \verb|.<field name>|。例如，仅仅打印名字：
\begin{lstlisting}
fmt.Printf("%s", a.name) |\coderemark{\%s 格式化字符串}|
\end{lstlisting}

\subsection{结构字段}
每个在结构中的项目被称为字段。
没有字段的结构：
\begin{lstlisting}
struct {}
\end{lstlisting}
有五个字段的：
\begin{lstlisting}
struct {
        x, y int
        _ float64  |\coderemark{填充}|
        A *[]int
        F func()
}
\end{lstlisting}
如果省略字段的名字，可以创建匿名字段，例如：
\begin{lstlisting}
struct {
        T1        // 字段名字是 T1
        *T2       // 字段名字是 T2
        P.T3      // 字段名字是 T3
        x, y int  // 字段名字是 x 和 y
}
\end{lstlisting}
Note the field names that start with a capital letter are exported, i.e. can be
set or read from other packages. Field names that start with a lowercase are private
to the current package. The same goes for functions defined in packages, see chapter
\ref{chap:packages}.

\subsection{Methods}
\label{sec:methods}
If you create functions that works on your newly defined type, you can
take two routes:
\begin{enumerate}
\item Create a function that takes the type as an argument.
\begin{lstlisting}
func doSomething(in1 *NameAge, in2 int) { /* ... */ }
\end{lstlisting}
This is (you might have guessed) a \first{\emph{function call}}{function!call}.
\item Create a function that works on the type (see \emph{receiver} in
listing \ref{src:function definition}):
\begin{lstlisting}
func (in1 *NameAge) doSomething(in2 int) { /* ... */ }
\end{lstlisting}
This is a \first{\emph{method call}}{method call}, which can be
used as: 
\begin{lstlisting}
var n *NameAge
n.doSomething(2)
\end{lstlisting}
\end{enumerate}
But keep the following in mind, this is quoted from \cite{go_spec}:
\begin{quote}
If \type{x} is
addressable and \lstinline{&x}'s method set contains \func{m}, 
\lstinline{x.m()} is shorthand for \lstinline{(&x).m()}.
\end{quote}
In the above case this means that the following is \emph{not} an 
error:
\begin{lstlisting}
var n NameAge	    |\coderemark{Not a pointer}|
n.doSomething(2)    
\end{lstlisting}
Here Go will search the method list for \var{n} of type \type{NameAge},
come up empty and will then \emph{also} search the method list for
the type \type{*NameAge} and will translate this call to
\lstinline{(&n).doSomething(2)}.

\section{Conversions}
\label{sec:conversions}
Sometimes you want to convert a type to another type. 
This is possible in Go, but
there are some rules. For starters, converting from one value to another
is done by functions and not all conversions are allowed.

\begin{table}[H]
\begin{center}
\caption[Valid conversions]{Valid conversions, 
\lstinline{float64} works the same as \lstinline{float32}}
\label{tab:convesion}
\input{tab/conversion.tex}
\end{center}
\end{table}

\begin{itemize}
\item{
From a \lstinline{string} to a slice of bytes or ints.
\begin{lstlisting}
mystring := "hello this is string"
\end{lstlisting}

\begin{lstlisting}
byteslice := []byte(mystring)
\end{lstlisting}
Converts to a \type{byte} slice, each \type{byte} contains the integer value
of the corresponding byte in the string. Note that as strings in Go
are encoded in UTF-8 some characters in the string may end up in 1, 2, 3
or 4 bytes.
\begin{lstlisting}
intslice  := []int(mystring)
\end{lstlisting}
Converts to an \type{int} slice, each \type{int} contains a Unicode code
point. Every character from the string is corresponds to one integer.
}
\item{
From a slice of bytes or ints to a \lstinline{string}.
\begin{lstlisting}
b := []byte{'h','e','l','l','o'} |\coderemark{Composite literal}|
s := string(b)
i := []int{257,1024,65} 
r := string(i)
\end{lstlisting}
}
\end{itemize}
For numeric values the following conversion are defined:
\begin{itemize}
\item{Convert to a integer with a specific (bit) length: 
\lstinline{uint8(int)};}
\item{From floating point to an integer value: 
\lstinline{int(float32)}. This discards the fraction part
from the floating point value;}
\item{The other way around: \lstinline{float32(int)};}
\end{itemize}

\subsection{User defined types and conversions}
How can you convert between the types you have defined
yourself?
We create two types here \type{Foo} and \type{Bar}, where
\lstinline{Bar} is an alias for \type{Foo}:
\begin{lstlisting}
type foo struct { int }  |\coderemark{anonymous struct field}|
type bar foo             |\coderemark{bar is an alias for foo}|
\end{lstlisting}

Then we:
\begin{lstlisting}
var b bar = bar{1} |\coderemark{Declare \var{b} to be a \type{bar}}|
var f foo = b	   |\coderemark{Assign \var{b} to \var{f}}|
\end{lstlisting}
Which fails on the last line with:

\noindent\error{cannot use b (type bar) as type foo in assignment}

\noindent{}This can be fixed with a conversion:
\begin{lstlisting}
var f foo = foo(b)
\end{lstlisting}
Note the converting structures that are not identical in their fields
is more difficult. Also note that converting \lstinline{b} to a plain
\type{int} also fails; an integer is not the same as a structure containing
an integer.

\section{Exercises}
\input{ex-beyond/ex-map.tex}

\input{ex-beyond/ex-pointers.tex}

\input{ex-beyond/ex-double-linked-list.tex}

\input{ex-beyond/ex-cat.tex}

\input{ex-beyond/ex-pointers-method.tex}

\cleardoublepage
\section{Answers}
\shipoutAnswer
