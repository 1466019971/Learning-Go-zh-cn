\epi{Go 有指针，但是没有指针运算。你不能用指针变量遍历字符串的各个字节。
}{\textit{Go For C++
Programmers}\\{\textsc{GO AUTHORS}}}
\noindent{}
Go 有指针。然而却没有指针运算，因此它们更象是引用而不是你所知道的来自于 C 的指针。
指针非常有用。
在 Go 中调用函数的时候，得记得变量是\emph{值传递}的。
因此，为了修改一个传递\emph{入}函数的值的效率和可能性，有了指针。

跟 C 中一样，用类型前的 '\key{*}' 定义一个指针：
\lstinline{var p *int}。现在 \var{p} 是一个指向整数值的指针。
所有新定义的变量都被赋值为其类型的零值，而指针也一样。
一个新定义的或者没有任何指向的指针，有值 \first{nil}{nil}。
在其他语言中，这经常被叫做空（NULL）指针，在 Go 中就是 \var{nil}。
让指针指向某些内容，可以使用\first{取址操作符}{operator!address-of}
（\func{\&}），像第 5 行那样：
\begin{lstlisting}[caption=Use of a pointer,label=src:pointers]
var p *int
fmt.Printf("%v", p) |\coderemark{打印 \var{nil}}|

var i int	    |\coderemark{定义一个整形变量 \var{i}}|
p = &i		    |\coderemark{使得 \var{p} 指向 \var{i}}|

fmt.Printf("%v", p) |\coderemark{打印出来的内容类似 \var{0x7ff96b81c000a}}|
\end{lstlisting}

更简单来说：\var{*X} 是指向 \type{X} 的指针；\var{[3]X} 是有三个 \type{X} 的数组。
因此类型更加容易从类型变化的名称上来理解：
\type{[]} 定义了 slice；
'\key{*}'
定义了指针；
\type{[size]} 定义了数组。因此 \type{[]*[3]*X} 是一个 slice，
元素是指向有三个元素的数组的指针，数组元素是指向 \type{X} 的指针。
（参阅 \ref{fig:pointers}）。
\begin{figure}[h]
\caption[Pointers and types]{指针和类型，值 \var{v} 全部为 \type{X} 类型}
\label{fig:pointers}
\begin{center}
\includegraphics[scale=0.65]{fig/pointers.pdf}
\end{center}
\end{figure}

从指针获取值是通过在指针变量前置'\type{*}'实现的：
\begin{lstlisting}[caption=获取指针指向的值,label=src:deref]
p = &i			|\coderemark{获取 \var{i} 的地址}|
*p = 8			|\coderemark{修改 \var{i} 的值}|
fmt.Printf("%v\n", *p)  |\coderemark{打印 8}|
fmt.Printf("%v\n", i)	|\coderemark{同上}|
\end{lstlisting}

前面已经说了，没有指针运算，所以如果这样写：
\lstinline{*p++}，它表示 \lstinline{(*p)++}：首先获取指针指向的值，然后对这个值加一。
\index{operator!increment}


\section{Allocation}
Go has garbage collection, meaning that you don't have to worry about
memory allocation and deallocation. Of course almost every language
since 1980 has this, but it is nice to see garbage collection in a
C-like language.

Go has two allocation primitives, \key{new} and \key{make}. They do different
things and apply to different types, which can be confusing, but the
rules are simple.
The following sections show how to handle allocation
in Go and hopefully clarifies the somewhat artificial distinction between
\first{\key{new}}{built-in!new} and \first{\key{make}}{built-in!make}. 

\subsection{Allocation with new}
\label{sec:allocation with new}
The built-in function \key{new} is 
essentially the same as its namesakes in other languages: \func{new(T)}
allocates zeroed storage for a new item of type \type{T} and returns its
address, a value of type \type{*T}. In Go terminology, it returns a pointer to
a newly allocated zero value of type \type{T}. This is important to
remember:
\begin{lbar}
\key{new} returns \emph{pointers}.
\end{lbar}

This
means a user of the data structure can create one with \key{new} and get
right to work. For example, the documentation for \func{bytes.Buffer} states
that "the zero value for Buffer is an empty buffer ready to use."
Similarly, \func{sync.Mutex} does not have an explicit constructor or Init
method. Instead, the zero value for a \func{sync.Mutex} is defined to be an
unlocked mutex.

The zero-value-is-useful property works transitively. Consider this type
declaration. See section "\titleref{sec:defining your own}" on page
\pageref{sec:defining your own}.

\begin{lstlisting}
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
\end{lstlisting}
Values of type \type{SyncedBuffer} are also ready to use immediately upon
allocation or just declaration. In this snippet, both \var{p} and
\var{v} will work
correctly without further arrangement.
\begin{lstlisting}
p := new(SyncedBuffer)  |\coderemark{Type *SyncedBuffer}|
var v SyncedBuffer      |\coderemark{Type  SyncedBuffer}|
\end{lstlisting}

\subsection{Allocation with make}
\label{sec:allocation with make}
Back to allocation. The built-in function \func{make(T, args)} serves a purpose
different from \func{new(T)}. It creates slices, maps, and channels only, and
it returns an initialized (not zero) value of type \type{T}, not
\type{*T}. The reason
for the distinction is that these three types are, under the covers,
references to data structures that must be initialized before use. A
slice, for example, is a three-item descriptor containing a pointer to
the data (inside an array), the length, and the capacity; until those
items are initialized, the slice is \type{nil}. For slices, maps, and channels,
\key{make} initializes the internal data structure and prepares the value for
use. 

\begin{lbar}
\key{make} returns initialized (non zero) \emph{values}.
\end{lbar}

For instance,
\lstinline{make([]int, 10, 100)}
allocates an array of 100 ints and then creates a slice structure with
length 10 and a capacity of 100 pointing at the first 10 elements of the
array. In contrast,
\lstinline{new([]int)} returns
a pointer to a newly allocated, zeroed slice structure, that is, a
pointer to a \type{nil} slice value.

These examples illustrate the difference between \key{new} and
\key{make}.
\begin{lstlisting}
var p *[]int = new([]int)       // allocates slice structure; *p == nil
				// rarely useful
var v  []int = make([]int, 100) // v refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
\end{lstlisting}
Remember that \key{make} applies only to maps, slices and channels and does
not return a pointer. To obtain an explicit pointer allocate with
\key{new}.

\subsection{Constructors and composite literals}
Sometimes the zero value isn't good enough and an initializing
constructor is necessary, as in this example taken from the package
\package{os}.
\begin{lstlisting}
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
\end{lstlisting}
There's a lot of boiler plate in there. We can simplify it using a
composite literal, which is an expression that creates a new instance
each time it is evaluated.

\begin{lstlisting}
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}	|\coderemark{Create a new \type{File}}|
    return &f			|\coderemark{Return the address of \var{f}}|
}
\end{lstlisting}
It is OK to return the address of a local variable;
the storage associated with the variable survives after the function
returns.

In fact, taking the address of a composite literal allocates a
fresh instance each time it is evaluated, so we can combine these last
two lines.\footnote{Taking the address of a composite literal tells the 
compiler to allocate it on the heap, not the stack.}
\begin{lstlisting}
return &File{fd, name, nil, 0}
\end{lstlisting}
The fields of a composite literal are laid out in order and must all be
present. However, by labeling the elements explicitly as field:value
pairs, the initializers can appear in any order, with the missing ones
left as their respective zero values. Thus we could say

\begin{lstlisting}
return &File{fd: fd, name: name}
\end{lstlisting}
As a limiting case, if a composite literal contains no fields at all, it
creates a zero value for the type. The expressions
\lstinline{new(File)} and 
\lstinline|&File{}| are equivalent.

Composite literals can also be created for arrays, slices, and maps,
with the field labels being indices or map keys as appropriate. In these
examples, the initializations work regardless of the values of
\var{Enone},
\var{Eio}, and \var{Einval}, as long as they are distinct.
\begin{lstlisting}
ar := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
sl := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
ma := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
\end{lstlisting}

\section{Defining your own types}
\label{sec:defining your own}
Of course Go allows you to define new types, it does this 
with the \first{\key{type}}{keyword!type} keyword: 
\begin{lstlisting}
type foo int
\end{lstlisting}
Creates
a new type \lstinline{foo} which acts like an \lstinline{int}.
Creating more sophisticated types is done with the
\first{\key{struct}}{keyword!struct}
keyword.
An example would be when we want record somebody's name (\type{string})
and age (\type{int}) in a single structure and make it a new type:
\lstinputlisting[label=src:struct,caption=Structures]{src/struct.go}
Apropos, the output of \lstinline{fmt.Printf("%v\n", a)} is 
\begin{display}
&\{Pete 42\}
\end{display}
That is nice!
Go knows how to print your structure. If you
only want to print one, or a few, fields of the structure you'll
need to use \verb|.<field name>|. For example to only print the name:
\begin{lstlisting}
fmt.Printf("%s", a.name) |\coderemark{\%s formats a string}|
\end{lstlisting}

\subsection{More on structure fields}
Each item in a structure is called a field. 
A struct with no fields:
\begin{lstlisting}
struct {}
\end{lstlisting}
One with five fields:
\begin{lstlisting}
struct {
        x, y int
        _ float64  |\coderemark{padding}|
        A *[]int
        F func()
}
\end{lstlisting}
If you omit the name for a field, you create an anonymous field, for
instance:
\begin{lstlisting}
struct {
        T1        // field name is T1
        *T2       // field name is T2
        P.T3      // field name is T3
        x, y int  // field names are x and y
}
\end{lstlisting}
Note the field names that start with a capital letter are exported, i.e. can be
set or read from other packages. Field names that start with a lowercase are private
to the current package. The same goes for functions defined in packages, see chapter
\ref{chap:packages}.

\subsection{Methods}
\label{sec:methods}
If you create functions that works on your newly defined type, you can
take two routes:
\begin{enumerate}
\item Create a function that takes the type as an argument.
\begin{lstlisting}
func doSomething(in1 *NameAge, in2 int) { /* ... */ }
\end{lstlisting}
This is (you might have guessed) a \first{\emph{function call}}{function!call}.
\item Create a function that works on the type (see \emph{receiver} in
listing \ref{src:function definition}):
\begin{lstlisting}
func (in1 *NameAge) doSomething(in2 int) { /* ... */ }
\end{lstlisting}
This is a \first{\emph{method call}}{method call}, which can be
used as: 
\begin{lstlisting}
var n *NameAge
n.doSomething(2)
\end{lstlisting}
\end{enumerate}
But keep the following in mind, this is quoted from \cite{go_spec}:
\begin{quote}
If \type{x} is
addressable and \lstinline{&x}'s method set contains \func{m}, 
\lstinline{x.m()} is shorthand for \lstinline{(&x).m()}.
\end{quote}
In the above case this means that the following is \emph{not} an 
error:
\begin{lstlisting}
var n NameAge	    |\coderemark{Not a pointer}|
n.doSomething(2)    
\end{lstlisting}
Here Go will search the method list for \var{n} of type \type{NameAge},
come up empty and will then \emph{also} search the method list for
the type \type{*NameAge} and will translate this call to
\lstinline{(&n).doSomething(2)}.

\section{Conversions}
\label{sec:conversions}
Sometimes you want to convert a type to another type. 
This is possible in Go, but
there are some rules. For starters, converting from one value to another
is done by functions and not all conversions are allowed.

\begin{table}[H]
\begin{center}
\caption[Valid conversions]{Valid conversions, 
\lstinline{float64} works the same as \lstinline{float32}}
\label{tab:convesion}
\input{tab/conversion.tex}
\end{center}
\end{table}

\begin{itemize}
\item{
From a \lstinline{string} to a slice of bytes or ints.
\begin{lstlisting}
mystring := "hello this is string"
\end{lstlisting}

\begin{lstlisting}
byteslice := []byte(mystring)
\end{lstlisting}
Converts to a \type{byte} slice, each \type{byte} contains the integer value
of the corresponding byte in the string. Note that as strings in Go
are encoded in UTF-8 some characters in the string may end up in 1, 2, 3
or 4 bytes.
\begin{lstlisting}
intslice  := []int(mystring)
\end{lstlisting}
Converts to an \type{int} slice, each \type{int} contains a Unicode code
point. Every character from the string is corresponds to one integer.
}
\item{
From a slice of bytes or ints to a \lstinline{string}.
\begin{lstlisting}
b := []byte{'h','e','l','l','o'} |\coderemark{Composite literal}|
s := string(b)
i := []int{257,1024,65} 
r := string(i)
\end{lstlisting}
}
\end{itemize}
For numeric values the following conversion are defined:
\begin{itemize}
\item{Convert to a integer with a specific (bit) length: 
\lstinline{uint8(int)};}
\item{From floating point to an integer value: 
\lstinline{int(float32)}. This discards the fraction part
from the floating point value;}
\item{The other way around: \lstinline{float32(int)};}
\end{itemize}

\subsection{User defined types and conversions}
How can you convert between the types you have defined
yourself?
We create two types here \type{Foo} and \type{Bar}, where
\lstinline{Bar} is an alias for \type{Foo}:
\begin{lstlisting}
type foo struct { int }  |\coderemark{anonymous struct field}|
type bar foo             |\coderemark{bar is an alias for foo}|
\end{lstlisting}

Then we:
\begin{lstlisting}
var b bar = bar{1} |\coderemark{Declare \var{b} to be a \type{bar}}|
var f foo = b	   |\coderemark{Assign \var{b} to \var{f}}|
\end{lstlisting}
Which fails on the last line with:

\noindent\error{cannot use b (type bar) as type foo in assignment}

\noindent{}This can be fixed with a conversion:
\begin{lstlisting}
var f foo = foo(b)
\end{lstlisting}
Note the converting structures that are not identical in their fields
is more difficult. Also note that converting \lstinline{b} to a plain
\type{int} also fails; an integer is not the same as a structure containing
an integer.

\section{Exercises}
\input{ex-beyond/ex-map.tex}

\input{ex-beyond/ex-pointers.tex}

\input{ex-beyond/ex-double-linked-list.tex}

\input{ex-beyond/ex-cat.tex}

\input{ex-beyond/ex-pointers-method.tex}

\cleardoublepage
\section{Answers}
\shipoutAnswer
